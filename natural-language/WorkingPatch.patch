diff --git a/RtmNet/RtmNet.csproj b/RtmNet/RtmNet.csproj
index 127a70a..145e4e8 100644
--- a/RtmNet/RtmNet.csproj
+++ b/RtmNet/RtmNet.csproj
@@ -9,7 +9,7 @@
     <OutputType>Library</OutputType>
     <NoStandardLibraries>false</NoStandardLibraries>
     <AssemblyName>RtmNet</AssemblyName>
-    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
     <FileAlignment>512</FileAlignment>
     <RootNamespace>RtmNet</RootNamespace>
   </PropertyGroup>
diff --git a/src/TaskTreeView.cs b/src/TaskTreeView.cs
index 202ca61..0d81ef3 100644
--- a/src/TaskTreeView.cs
+++ b/src/TaskTreeView.cs
@@ -640,7 +640,7 @@ namespace Tasque
 				
 				string parsedTaskText;
 				DateTime parsedDueDate;
-				Utilities.ParseTaskText (newText, out parsedTaskText, out parsedDueDate);
+				DateGuesser.Instance.Parse (newText, out parsedTaskText, out parsedDueDate);
 				
 				if (parsedDueDate != DateTime.MinValue)
 					task.DueDate = parsedDueDate;
diff --git a/src/TaskWindow.cs b/src/TaskWindow.cs
index e51c221..0d849ae 100644
--- a/src/TaskWindow.cs
+++ b/src/TaskWindow.cs
@@ -952,7 +952,7 @@ namespace Tasque
 			DateTime taskDueDate = DateTime.MinValue;
 			string taskName;
 			if (Application.Preferences.GetBool (Preferences.ParseDateEnabledKey))
-				Utilities.ParseTaskText (
+				DateGuesser.Instance.Parse (
 				                         enteredTaskText,
 				                         out taskName,
 				                         out taskDueDate);
diff --git a/src/Utilities.cs b/src/Utilities.cs
index a5e26fe..ac5135e 100644
--- a/src/Utilities.cs
+++ b/src/Utilities.cs
@@ -2,9 +2,11 @@
  *  Utilities.cs
  *
  *  Copyright (C) 2007 Novell, Inc.
+ *  Copyright (C) 2010 Mario Carrion
  *  Written by:
  * 		Calvin Gaisford <calvinrg@gmail.com>
  *		Boyd Timothy <btimothy@gmail.com>
+ * 		Mario Carrion <mario@carrion.mx>
  ****************************************************************************/
 
 /*  THIS FILE IS LICENSED UNDER THE MIT LICENSE AS OUTLINED IMMEDIATELY BELOW: 
@@ -41,7 +43,8 @@ using Gtk;
 
 namespace Tasque
 {
-	internal class Utilities
+	// TODO: Change this class to internal
+	public static partial class Utilities
 	{
 		public static string ReplaceString (string originalString, string searchString, string replaceString)
 		{
@@ -310,102 +313,6 @@ namespace Tasque
 
 			return pretty_str;
 		}
-		
-		public static string GetLocalizedDayOfWeek (System.DayOfWeek dayOfWeek)
-		{
-			switch (dayOfWeek) {
-			case DayOfWeek.Sunday:
-				return Catalog.GetString ("Sunday");
-			case DayOfWeek.Monday:
-				return Catalog.GetString ("Monday");
-			case DayOfWeek.Tuesday:
-				return Catalog.GetString ("Tuesday");
-			case DayOfWeek.Wednesday:
-				return Catalog.GetString ("Wednesday");
-			case DayOfWeek.Thursday:
-				return Catalog.GetString ("Thursday");
-			case DayOfWeek.Friday:
-				return Catalog.GetString ("Friday");
-			case DayOfWeek.Saturday:
-				return Catalog.GetString ("Saturday");
-			}
-			
-			return string.Empty;
-		}
-		
-		/// <summary>
-		/// Parse the task name in order to derive due date information.
-		/// </summary>
-		/// <param name="enteredTaskText">
-		/// A <see cref="System.String"/> representing the text entered
-		/// into the task name field.
-		/// </param>
-		/// <param name="parsedTaskText">
-		/// The enteredTaskText with the due date section of the string
-		/// removed.
-		/// </param>
-		/// <param name="parsedDueDate">
-		/// The due date derived from enteredTaskText, or
-		/// DateTime.MinValue if no date information was found.
-		/// </param>
-		public static void ParseTaskText (string enteredTaskText, out string parsedTaskText, out DateTime parsedDueDate)
-		{
-			// First, look for ways that the right side of the entered
-			// text can be directly parsed as a date
-			string[] words = enteredTaskText.Split (' ');
-			for (int i = 1; i < words.Length; i++) {
-				string possibleDate = string.Join (" ", words, i, words.Length - i);
-				DateTime result;
-				if (DateTime.TryParse (possibleDate, out result)) {
-					// Favor future dates, unless year was specifically mentioned
-					if (!possibleDate.Contains (result.Year.ToString ()))
-						while (result < DateTime.Today)
-							result = result.AddYears (1);
-					
-					// Set task due date and return the task
-					// name with the date part removed.
-					parsedDueDate = result;
-					parsedTaskText = string.Join (" ", words, 0, i);
-					return;
-				}
-			}
-			
-			// Then try some more natural language parsing
-			
-			// A regular expression to capture a task that is due today
-			string today = Catalog.GetString (@"^(?<task>.+)\s+today\W*$");
-			// A regular expression to capture a task that is due tomorrow
-			string tomorrow = Catalog.GetString (@"^(?<task>.+)\s+tomorrow\W*$");
-			
-			// Additional regular expressions to consider using
-			//string abbrevDate = Catalog.GetString (@"^(?<task>.+)(on )?(the )?(?<day>\d{1,2})((th)|(nd)|(rd)|(st))\W*$");
-			//string nextDayName = Catalog.GetString (@"^(?<task>.+)(on )?next\s+(?<day>[a-z]+)\W*$");
-			//string dayName = Catalog.GetString (@"^(?<task>.+)\s+(on )?(?<day>[a-z]+)\W*$");
-			
-			Match match = Regex.Match (enteredTaskText, today, RegexOptions.IgnoreCase);
-			if (match.Success) {
-				string trimmedTaskText = match.Groups ["task"].Value;
-				if (!string.IsNullOrEmpty (trimmedTaskText)) {
-					parsedDueDate = DateTime.Now;
-					parsedTaskText = trimmedTaskText;
-					return;
-				}
-			}
-			
-			match = Regex.Match (enteredTaskText, tomorrow, RegexOptions.IgnoreCase);
-			if (match.Success) {
-				string trimmedTaskText = match.Groups ["task"].Value;
-				if (!string.IsNullOrEmpty (trimmedTaskText)) {
-					parsedDueDate = DateTime.Now.AddDays (1);
-					parsedTaskText = trimmedTaskText;
-					return;
-				}
-			}
-			
-			parsedTaskText = enteredTaskText;
-			parsedDueDate = DateTime.MinValue;
-			return;
-		}
 
 		/// <summary>
 		/// This returns the hexadecimal value of an GDK color.
diff --git a/src/libtasque/Constants.cs b/src/libtasque/Constants.cs
new file mode 100644
index 0000000..20c2ba2
--- /dev/null
+++ b/src/libtasque/Constants.cs
@@ -0,0 +1,93 @@
+// Author:
+//       Mario Carrion <mario@carrion.mx>
+// 
+// Copyright (c) 2010 Mario Carrion
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using Mono.Unix;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+
+namespace Tasque {
+
+	public static class Constants {
+
+		#region Members used by DateGuesser
+
+		// As in "due before April 1st", "due Wednesday", "due by tomorrow"
+		public static readonly string Due = Catalog.GetString ("due before|due by|due");
+
+		public static readonly string Today = Catalog.GetString ("today");
+
+		public static readonly string Tomorrow = Catalog.GetString ("tomorrow");
+
+		public static readonly string Week = Catalog.GetString ("week");
+
+		public static readonly string Month = Catalog.GetString ("month");
+
+		public static readonly string Year = Catalog.GetString ("year");
+
+		// As in "Next Month" or "Next Monday"
+		public static readonly string Next = Catalog.GetString ("next");
+
+		// As in "On April 1st" or "On Wednesday"
+		public static readonly string On = Catalog.GetString ("on");
+
+		// As in 1st, 2nd, 3rd
+		public static readonly string OrdinalNumbers = Catalog.GetString ("st|nd|rd|th");
+
+		public static string[] Weekdays {
+			get {
+				if (weekdays == null) {
+					List<string> list  = new List<string> ();
+					// To begin on Sunday January 7th 1900.
+					// Sunday is our index 0
+					foreach (int day in Enumerable.Range (7, 7)) {
+						DateTime date = new DateTime (1900, 1, day);
+						list.Add (date.ToString ("dddd").ToLower ());
+						list.Add (date.ToString ("ddd").ToLower ());
+					}
+					weekdays = list.ToArray ();
+				}
+				return weekdays;
+			}
+		}
+		static string[] weekdays;
+
+		public static string[] Months {
+			get {
+				if (months == null) {
+					List<string> list  = new List<string> ();
+					foreach (int month in Enumerable.Range (1, 12)) {
+						DateTime date = new DateTime (1900, month, 1);
+						list.Add (date.ToString ("MMMM").ToLower ());
+						list.Add (date.ToString ("MMM").ToLower ());
+					}
+					months = list.ToArray ();
+				}
+				return months;
+			}
+		}
+		static string[] months;
+
+		#endregion
+	}
+}
diff --git a/src/libtasque/DateGuesser.cs b/src/libtasque/DateGuesser.cs
new file mode 100644
index 0000000..ddfd213
--- /dev/null
+++ b/src/libtasque/DateGuesser.cs
@@ -0,0 +1,166 @@
+//
+// Author:
+//      Mario Carrion <mario@carrion.mx>
+//
+// Copyright (c) 2010 Mario Carrion
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using Mono.Unix;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Text.RegularExpressions;
+
+using Tasque.DateGuessers;
+
+namespace Tasque {
+
+	
+	public class DateGuesser {
+
+		#region Public Members
+
+		public bool Parse (string enteredTaskText,
+		                    out string parsedTaskText,
+		                    out DateTime parsedDueDate)
+		{
+			parsedTaskText = enteredTaskText;
+			parsedDueDate = DateTime.MinValue;
+
+			foreach (IDateGuesser guesser in guessers) {
+				// TODO: Is here the best place to add expression to get hour?
+				string regEx = string.Format (@"^(?<task>.+?)\s*?{0}(?<eol>.*)$",
+				                               guesser.Expression);
+				Match match = Regex.Match (enteredTaskText, regEx, RegexOptions.IgnoreCase);
+				if (match.Success) {
+					string trimmedTaskText = match.Groups ["task"].Value;
+					if (!string.IsNullOrEmpty (trimmedTaskText)) {
+						if (!guesser.Format (match.Groups ["date"].Value, 
+						                     out parsedDueDate))
+							return false;
+	
+						string trimmedEofText = match.Groups ["eol"].Value;
+						parsedTaskText = string.Format ("{0}{1}", trimmedTaskText, trimmedEofText);
+						return true;
+					}
+				} 
+			}
+
+			return false;
+		}
+
+		#endregion
+
+		#region Private Members
+
+		private DateGuesser ()
+		{
+			guessers = new List<IDateGuesser> ();
+			guessers.Add (new TodayTomorrowGuesser ());
+			guessers.Add (new NextGuesser ());
+			guessers.Add (new DueGuesser ());
+		}
+
+		List<IDateGuesser> guessers;
+
+		#endregion
+
+		#region Static Members
+
+		public static DateGuesser Instance {
+			get {
+				if (instance == null)
+					instance = new DateGuesser ();
+				return instance;
+			}
+		}
+
+		public static uint DayOfWeekToUInt (DayOfWeek weekDay)
+		{
+			switch (weekDay) {
+			case DayOfWeek.Sunday:
+				return 0;
+			case DayOfWeek.Monday:
+				return 1;
+			case DayOfWeek.Tuesday:
+				return 2;
+			case DayOfWeek.Wednesday:
+				return 3;
+			case DayOfWeek.Thursday:
+				return 4;
+			case DayOfWeek.Friday:
+				return 5;
+			case DayOfWeek.Saturday:
+			default:
+				return 6;
+			}
+		}
+
+		public static bool IsMonth (string str)
+		{
+			return Constants.Months.Contains (str.ToLower ());
+		}
+
+		public static bool IsWeekday (string str)
+		{
+			return Constants.Weekdays.Contains (str.ToLower ());
+		}
+
+		public static DayOfWeek StringToDayOfWeek (string str)
+		{
+			str = str.ToLower ();
+			int indexOf = Array.IndexOf (Constants.Weekdays, str);
+			if (indexOf == -1)
+				throw new ArgumentException (string.Format ("Wrong day {0}", str));
+
+			switch (indexOf) {
+			case 0:
+			case 1:
+				return DayOfWeek.Sunday;
+			case 2:
+			case 3:
+				return DayOfWeek.Monday;
+			case 4:
+			case 5:
+				return DayOfWeek.Tuesday;
+			case 6:
+			case 7:
+				return DayOfWeek.Wednesday;
+			case 8:
+			case 9:
+				return DayOfWeek.Thursday;
+			case 10:
+			case 11:
+				return DayOfWeek.Friday;
+			case 12:
+			case 13:
+			default:
+				return DayOfWeek.Saturday;
+			}
+		}
+
+		static DateGuesser instance;
+
+		#endregion
+	}
+
+}
+
diff --git a/src/libtasque/DateGuessers/DueGuesser.cs b/src/libtasque/DateGuessers/DueGuesser.cs
new file mode 100644
index 0000000..3435c93
--- /dev/null
+++ b/src/libtasque/DateGuessers/DueGuesser.cs
@@ -0,0 +1,165 @@
+// Author:
+//       Mario Carrion <mario@carrion.mx>
+// 
+// Copyright (c) 2010 Mario Carrion
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using Mono.Unix;
+using System;
+using System.Collections.Generic;
+using System.Text.RegularExpressions;
+
+namespace Tasque.DateGuessers {
+
+	class DueGuesser : IDateGuesser {
+
+		// This is quite straightforward
+		// - 11|12|13=th -> numbers with sufix 11, 12 and 13 use "th"
+		// - 1=st -> numbers with sufix 1 use "st"
+		// - default=th -> all the others will use th
+		// and so on.
+		public static readonly string OrdinalNumbers = Catalog.GetString ("11|12|13=th,1=st,2=nd,3=rd,default=th");
+
+		public string Expression {
+			get {
+				// Examples:
+				// - Valid: "April 1", "April 1st", "April"
+				// - Invalid: "April 1nd"
+				return string.Format (@"\b({0})\b\s+?\b(?<date>({1})(\s*?\d{2}({3})?)?)\b",
+				                       Constants.Due.Replace (" ", @"\s+"),
+				                       string.Join ("|", Constants.Months),
+				                       "{1,2}",
+				                       Constants.OrdinalNumbers);
+			}
+		}
+
+		public bool Format (string dateExpression, out DateTime dateTime)
+		{
+			dateTime = DateTime.MinValue;
+
+			string[] values = dateExpression.Split (new char [] { ' ' }, 
+			                                        StringSplitOptions.RemoveEmptyEntries);
+
+			int month = Array.IndexOf (Constants.Months, 
+			                           values [0].ToLower ());
+			if (month == -1) 
+				return false;
+			// Months start in 1.
+			month = (month / 2) + 1;
+
+			// If no day is provided, default is 1st
+			int day = 1;
+			if (values.Length > 1) {
+				if (values [1].Length > 2) {
+					if (!IsValidOrdinalNumber (values [1], out day))
+						return false;
+				} else
+					day = Convert.ToInt32 (values [1]);
+			} 
+
+			int year =  DateTime.Today.Year;
+			if (DateTime.Today.Month > month)
+				year++;
+
+			try {
+				dateTime = new DateTime (year, month, day);
+			} catch (Exception ex) {
+				if (ex is ArgumentOutOfRangeException
+				    || ex is ArgumentException) {
+					return false;
+				} else
+					throw;
+			}
+
+			return true;
+		}
+
+		bool IsValidOrdinalNumber (string ordinal, out int day)
+		{
+			day = 0;
+
+			int cardinal = 0;
+			string sufix = string.Empty;
+			if (ordinal.Length == 3) { // something like 1st
+				cardinal = Convert.ToInt32 (ordinal [0]);
+				sufix = ordinal.Substring (1);
+			} else { // something like 11th
+				cardinal = Convert.ToInt32 (ordinal.Substring (0, 2));
+				sufix = ordinal.Substring (2);
+			}
+
+			string expectedSufix = string.Empty;
+			if (!Dictionary.TryGetValue (cardinal, out expectedSufix)) {
+				// It was not found and the last digit is still valid, 
+				// ie, 22nd, should use 2nd
+				if (cardinal > 9) {
+					int c = Convert.ToInt32 (ordinal.Substring (1, 1));
+					// and if that is still failing, then use default sufix
+					if (!Dictionary.TryGetValue (c, out expectedSufix))
+						expectedSufix = defaultSufix;
+				} else
+					expectedSufix = defaultSufix;
+			}
+
+			if (expectedSufix != sufix)
+				return false;
+
+			day = cardinal;
+			return true;
+		}
+		
+		Dictionary<int,string> Dictionary {
+			get {
+				if (dictionary == null) {
+					// Matches: "11|12|13"
+					string alternatives = @"((\d{1,2})+(\|\d{1,2})*)";
+					// Matches: "11""12""13", used when "11|12|13=th,2=nd"
+					string days = @"\b((\d{1,2})+((?<=\|)\d{1,2})*)\b";
+					// Matches "dayOrDays=sufix"
+					string expression
+						= string.Format (@"\b(?<days>({0}|\w+))=(?<sufix>\w+)\b", alternatives);
+					dictionary = new Dictionary<int, string> ();
+
+					Regex regex = new Regex (expression,
+					                         RegexOptions.IgnoreCase);
+					foreach (Match match in regex.Matches (DueGuesser.OrdinalNumbers)) {
+						Regex regexDays = new Regex (days, RegexOptions.IgnoreCase);
+						MatchCollection matchDays = regexDays.Matches (match.Groups ["days"].Value);
+						// Adding, 11=th, 12=th, 13=th
+						foreach (Match matchDay in matchDays) {
+							if (matchDay.Value == "default") {
+								defaultSufix = match.Groups ["sufix"].Value;
+								break;
+							}
+							dictionary.Add (Convert.ToInt32 (matchDay.Value),
+							                match.Groups ["sufix"].Value);
+						}
+					}
+					if (defaultSufix == null)
+						throw new ArgumentNullException ("No default ordinal prefix provided");
+				}
+				return dictionary;
+			}
+		}
+		
+		Dictionary<int,string> dictionary;
+		string defaultSufix = string.Empty;
+	}
+}
diff --git a/src/libtasque/DateGuessers/IDateGuesser.cs b/src/libtasque/DateGuessers/IDateGuesser.cs
new file mode 100644
index 0000000..814547d
--- /dev/null
+++ b/src/libtasque/DateGuessers/IDateGuesser.cs
@@ -0,0 +1,34 @@
+//
+// Author:
+//      Mario Carrion <mario@carrion.mx>
+//
+// Copyright (c) 2010 Mario Carrion
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+
+namespace Tasque.DateGuessers {
+
+	interface IDateGuesser {
+		string Expression { get;}
+		bool Format (string dateExpression, out DateTime dateTime);
+	}
+
+}
diff --git a/src/libtasque/DateGuessers/NextGuesser.cs b/src/libtasque/DateGuessers/NextGuesser.cs
new file mode 100644
index 0000000..aed933e
--- /dev/null
+++ b/src/libtasque/DateGuessers/NextGuesser.cs
@@ -0,0 +1,72 @@
+// Author:
+//       Mario Carrion <mario@carrion.mx>
+// 
+// Copyright (c) 2010 Mario Carrion
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+using System.Text;
+
+namespace Tasque.DateGuessers {
+	
+	// Guesses "XXXX next XXX"
+	class NextGuesser : IDateGuesser {
+		public string Expression { 
+			get {
+				StringBuilder strBuilder = new StringBuilder ();
+				strBuilder.Append (string.Format ("{0}|", Constants.Week));
+				strBuilder.Append (string.Format ("{0}|", Constants.Month));
+				strBuilder.Append (string.Format ("{0}|", Constants.Year));
+				strBuilder.Append (string.Join ("|", Constants.Weekdays));
+
+				return string.Format (@"\b(({0}\s+)?{1})\b\s+\b(?<date>({2})?)\b",
+				                       Constants.On,
+				                       Constants.Next,
+				                       strBuilder.ToString ());
+			}
+		}
+
+		public bool Format (string dateExpression, out DateTime dateTime)
+		{
+			dateTime = DateTime.MinValue;
+			
+			if (dateExpression == Constants.Week)
+				dateTime = DateTime.Now.AddDays (7);
+			else if (dateExpression == Constants.Month)
+				dateTime = DateTime.Now.AddMonths (1);
+			else if (dateExpression == Constants.Year)
+				dateTime = DateTime.Now.AddYears (1);
+			else if (DateGuesser.IsWeekday (dateExpression)) {
+				DateTime todayDateTime = DateTime.Now;
+				uint today = DateGuesser.DayOfWeekToUInt (todayDateTime.DayOfWeek);
+				uint future = DateGuesser.DayOfWeekToUInt (DateGuesser.StringToDayOfWeek (dateExpression));
+				if (future > today) 
+					dateTime = DateTime.Now.AddDays (future - today);
+				else if (today > future)
+					dateTime = DateTime.Now.AddDays (7 - (today - future));
+				else // future is in one week
+					dateTime = DateTime.Now.AddDays (7);
+			} else
+				return false;
+
+			return true;
+		}
+	}
+}
diff --git a/src/libtasque/DateGuessers/NumericDateGuesser.cs b/src/libtasque/DateGuessers/NumericDateGuesser.cs
new file mode 100644
index 0000000..da09905
--- /dev/null
+++ b/src/libtasque/DateGuessers/NumericDateGuesser.cs
@@ -0,0 +1,50 @@
+// Author:
+//       Mario Carrion <mario@carrion.mx>
+// 
+// Copyright (c) 2010 Mario Carrion
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+
+namespace Tasque.DateGuessers {
+
+	class NumericDateGuesser : IDateGuesser {
+
+		public string Expression { 
+			get {
+				return @"(?<date>[0-3]?[0-9]/[0-3]?[0-9]/(?:[0-9]{2})?[0-9]{2})";
+//				return string.Format (@"(({0})?)?\s+?\b(?<date>{1}|{2})\b",
+//				                       Constants.Due.Replace (" ", @"\s+"),
+//				                       Constants.Today,
+//				                       Constants.Tomorrow);
+			}
+		}
+
+		public bool Format (string dateExpression, out DateTime dateTime)
+		{
+			if (DateTime.TryParse (dateExpression, out dateTime))
+				return true;
+			else {
+				dateTime = DateTime.MinValue;
+				return false;
+			}
+		}
+	}
+}
\ No newline at end of file
diff --git a/src/libtasque/DateGuessers/OnGuesser.cs b/src/libtasque/DateGuessers/OnGuesser.cs
new file mode 100644
index 0000000..17909a4
--- /dev/null
+++ b/src/libtasque/DateGuessers/OnGuesser.cs
@@ -0,0 +1,49 @@
+// Author:
+//       Mario Carrion <mario@carrion.mx>
+// 
+// Copyright (c) 2010 Mario Carrion
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+
+namespace Tasque.DateGuessers {
+
+	class OnGuesser : IDateGuesser {
+
+		public string Expression {
+			get {
+				return string.Format (@"\b{0}\b\s+\b(?<date>{0})\b",
+				                       Constants.On,
+				                       string.Join ("|", Constants.Weekdays),
+				                       Constants.Tomorrow);
+			}
+		}
+
+		public bool Format (string dateExpression, out DateTime dateTime)
+		{
+			if (dateExpression == Constants.Tomorrow)
+				dateTime = DateTime.Now.AddDays (1);
+			else
+				dateTime = DateTime.Now;
+
+			return true;
+		}
+	}
+}
diff --git a/src/libtasque/DateGuessers/TomorrowTodayGuesser.cs b/src/libtasque/DateGuessers/TomorrowTodayGuesser.cs
new file mode 100644
index 0000000..fafc156
--- /dev/null
+++ b/src/libtasque/DateGuessers/TomorrowTodayGuesser.cs
@@ -0,0 +1,49 @@
+// Author:
+//       Mario Carrion <mario@carrion.mx>
+// 
+// Copyright (c) 2010 Mario Carrion
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+
+namespace Tasque.DateGuessers {
+
+	class TodayTomorrowGuesser : IDateGuesser {
+
+		public string Expression {
+			get {
+				return string.Format (@"(\b({0})\b?)?\s+?\b(?<date>{1}|{2})\b",
+				                       Constants.Due.Replace (" ", @"\s+"),
+				                       Constants.Today,
+				                       Constants.Tomorrow);
+			}
+		}
+
+		public bool Format (string dateExpression, out DateTime dateTime)
+		{
+			if (dateExpression == Constants.Tomorrow)
+				dateTime = DateTime.Now.AddDays (1);
+			else
+				dateTime = DateTime.Now;
+
+			return true;
+		}
+	}
+}
diff --git a/src/libtasque/RegularExpressionAttribute.cs b/src/libtasque/RegularExpressionAttribute.cs
new file mode 100644
index 0000000..d7ed00b
--- /dev/null
+++ b/src/libtasque/RegularExpressionAttribute.cs
@@ -0,0 +1,101 @@
+// Author:
+//       Mario Carrion <mario@carrion.mx>
+// 
+// Copyright (c) 2010 Mario Carrion
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+
+namespace Tasque {
+
+	[AttributeUsage (AttributeTargets.Field, AllowMultiple = false)]
+	class RegularExpressionAttribute : Attribute {
+
+		public RegularExpressionAttribute (string formatExpression, Type formatterType)
+		{
+			if (string.IsNullOrEmpty (formatExpression))
+				throw new ArgumentException ("formatExpression");
+			if (formatterType == null || formatterType.GetInterface ("IDateFormatter") == null)
+				throw new ArgumentException ("formatter");
+
+			FormatExpression = formatExpression;
+			FormatterType = formatterType;
+		}
+
+		public string FormatExpression {
+			get;
+			private set;
+		}
+
+		public Type FormatterType {
+			get;
+			private set;
+		}
+
+		public string RegularExpression {
+			get;
+			set;
+		}
+	}
+	
+	interface IDateFormatter {
+		DateTime GetDate (System.Text.RegularExpressions.Match match, string[] groups);
+	}
+	
+	class TodayTomorrowDateFormatter : IDateFormatter {
+		DateTime IDateFormatter.GetDate (System.Text.RegularExpressions.Match match, string[] groups)
+		{
+			return DateTime.Now;
+		}
+	}
+
+	class RegularExpressionFormat {
+		public RegularExpressionFormat (string regularExpression,
+		                                string formatExpression,
+		                                IDateFormatter formatter)
+		{
+			if (regularExpression == null)
+				throw new ArgumentNullException ("regularExpression");
+			if (formatExpression == null)
+				throw new ArgumentNullException ("formatExpression");
+			if (formatter == null)
+				throw new ArgumentNullException ("formatter");
+			
+			RegularExpression = regularExpression;
+			FormatExpression = formatExpression;
+			Formatter = formatter;
+		}
+
+		public string FormatExpression {
+			get;
+			private set;
+		}
+
+		public string RegularExpression {
+			get;
+			private set;
+		}
+
+		public IDateFormatter Formatter {
+			get;
+			private set;
+		}
+	}
+}
diff --git a/src/libtasque/RegularExpressions.cs b/src/libtasque/RegularExpressions.cs
new file mode 100644
index 0000000..253a9ff
--- /dev/null
+++ b/src/libtasque/RegularExpressions.cs
@@ -0,0 +1,133 @@
+// Author:
+//       Mario Carrion <mario@carrion.mx>
+// 
+// Copyright (c) 2010 Mario Carrion
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+using System.Linq;
+using System.Collections.Generic;
+using Mono.Unix;
+
+namespace Tasque {
+
+	public static class RegularExpressions {
+
+		[RegularToken ('M')]
+		public static readonly string Months = string.Join ("|", MonthsArray);
+
+		[RegularToken ('D')]
+		public static readonly string Weekdays = string.Join ("|", WeekdaysArray);
+
+		public static readonly string Today = Catalog.GetString ("today");
+		
+		public static readonly string Tomorrow = Catalog.GetString ("tomorrow");
+
+		[RegularToken ('T')]
+		public static readonly string TodayTomorrow = string.Format ("{0}|{1}", Today, Tomorrow);
+
+		[RegularToken ('O')]
+		public static readonly string OrdinalNumber = string.Format ("{0}{1}", @"\d{1,2}", OrdinalSuffixes);
+
+		// L10N: Read TRANSLATORS file for a detailed information about this string
+		public static readonly string OrdinalNumbers = Catalog.GetString ("11|12|13=th,1=st,2=nd,3=rd,default=th");
+
+		public static readonly string OrdinalSuffixes = Catalog.GetString ("st|nd|rd|th");
+
+		[RegularToken ('u')]
+		public static readonly string Due = Catalog.GetString ("due before|due by|due");
+
+		// L10N: First MUST be singular, second MUST be plural
+		[RegularToken ('w')]
+		public static readonly string Week = Catalog.GetString ("week|weeks");
+
+		// L10N: First MUST be singular, second MUST be plural
+		[RegularToken ('m')]
+		public static readonly string Month = Catalog.GetString ("month|months");
+
+		// L10N: First MUST be singular, second MUST be plural
+		[RegularToken ('y')]
+		public static readonly string Year = Catalog.GetString ("year|years");
+
+		// L10N: Examples could be: "Next Month", "Next Monday"
+		[RegularToken ('n')]
+		public static readonly string Next = Catalog.GetString ("next");
+
+		// L10N: Examples could be: "On April 1st", "On Wednesday"
+		[RegularToken ('o')]
+		public static readonly string On = Catalog.GetString ("on");
+
+		#region Regular Expressions
+
+		// RegEx: Read TRANSLATORS file for a detailed information about this string
+		[RegularExpression ("T", typeof (TodayTomorrowDateFormatter))]
+		public static readonly string TodayTorromowExpression = Catalog.GetString (@"T|u \T\");
+
+		// RegEx: Read TRANSLATORS file for a detailed information about this string
+//		[RegularExpression ("w", null)]
+		public static readonly string NextExpression = Catalog.GetString ("n w");
+		//public static readonly string NextExpression = Catalog.GetString ("n w|n m|n y|n D");
+
+		// RegEx: Read TRANSLATORS file for a detailed information about this string
+//		[RegularExpression ("M O", null)]
+		public static readonly string DueExpression = Catalog.GetString (@"u \M O\"); // u 'de' \O 'de' M\
+
+		#endregion
+
+		#region Private Members
+
+		static string[] WeekdaysArray {
+			get {
+				if (weekdays == null) {
+					List<string> list  = new List<string> (7);
+					// To begin on Sunday January 7th 1900.
+					// Sunday is our index 0
+					foreach (int day in Enumerable.Range (7, 7)) {
+						DateTime date = new DateTime (1900, 1, day);
+						list.Add (date.ToString ("dddd").ToLower ());
+						list.Add (date.ToString ("ddd").ToLower ());
+					}
+					weekdays = list.ToArray ();
+				}
+				return weekdays;
+			}
+		}
+		static string[] weekdays;
+
+		static string[] MonthsArray {
+			get {
+				if (months == null) {
+					List<string> list  = new List<string> (12);
+					foreach (int month in Enumerable.Range (1, 12)) {
+						DateTime date = new DateTime (1900, month, 1);
+						list.Add (date.ToString ("MMMM").ToLower ());
+						list.Add (date.ToString ("MMM").ToLower ());
+					}
+					months = list.ToArray ();
+				}
+				return months;
+			}
+		}
+		static string[] months;
+
+		#endregion
+
+	}
+}
diff --git a/src/libtasque/RegularTokenAttribute.cs b/src/libtasque/RegularTokenAttribute.cs
new file mode 100644
index 0000000..bb60cf8
--- /dev/null
+++ b/src/libtasque/RegularTokenAttribute.cs
@@ -0,0 +1,49 @@
+// Author:
+//       Mario Carrion <mario@carrion.mx>
+// 
+// Copyright (c) 2010 Mario Carrion
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+
+namespace Tasque {
+
+	[AttributeUsage (AttributeTargets.Field, AllowMultiple = false)]
+	class RegularTokenAttribute : Attribute {
+
+		public RegularTokenAttribute (char token)
+		{
+			if (token == null)
+				throw new NullReferenceException ("token");
+
+			Token = token;
+		}
+
+		public char Token {
+			get;
+			set;
+		}
+
+		// TODO: Add dependencies and formatters.
+		// For example, if this class decorates 
+		// "Month" and the \date\ includes a "1st"
+		// we will use the formater XXXX
+	}
+}
diff --git a/src/libtasque/TaskParser.cs b/src/libtasque/TaskParser.cs
new file mode 100644
index 0000000..2088be1
--- /dev/null
+++ b/src/libtasque/TaskParser.cs
@@ -0,0 +1,183 @@
+// Author:
+//       Mario Carrion <mario@carrion.mx>
+// 
+// Copyright (c) 2010 Mario Carrion
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Reflection;
+using System.Text;
+using System.Text.RegularExpressions;
+
+namespace Tasque {
+
+	public class TaskParser {
+
+		// Matches anything like this: "a b cd|e f g 'xy'"
+		static readonly string AlternativesExpression = @"(\w|\s|\'|\\)+((?<=\|)(\w|\s|\'|\\)+)*";
+
+		// Matches format and explicit '' delimited text
+		static readonly string TokensExpression = @"(\b\w\b|'\w+')+((?<=\s)(\b\w\b|'\w+'))*";
+
+		// Expression that defines the named group "<?date>"
+		static readonly string DateGroupExpression  = @"(?>\\)(\b\w\b|'\w+')+(?>.*?\\)";
+
+		public TaskParser ()
+		{
+			fullExpression = string.Format ("{0}|{1}",
+			                                TokensExpression,
+			                                DateGroupExpression);
+
+			FillTranslatableTokens ();
+
+			regExFormats = GetRegularExpressions ();
+			foreach (RegularExpressionFormat format in regExFormats) {
+				Console.WriteLine ("{0} --> {1}", 
+				                   format.RegularExpression,
+				                   GenerateRegularExpression (format.RegularExpression));
+//				Console.WriteLine ("{0}={1}={2}", 
+//				                   format.RegularExpression, 
+//				                   format.FormatExpression, 
+//				                   format.Formatter);
+			}
+		}
+
+		public string GenerateRegularExpression (string translatedExpression)
+		{
+			List<string> expressionList = new List<string> ();
+			Regex regex = new Regex (fullExpression, RegexOptions.IgnoreCase);
+			foreach (Match match in regex.Matches (translatedExpression)) {
+				// We found a match for a string like this: "\Something\"
+				if (Regex.IsMatch (match.Value, DateGroupExpression)) {
+					Regex dateRegEx = new Regex (TokensExpression, RegexOptions.IgnoreCase);
+					string date = "(?<date>";
+					List<string> dateList = new List<string> ();
+					foreach (Match token in dateRegEx.Matches (match.Value))
+						dateList.Add (GetFormatedToken (token));
+					date += string.Join (@"\s+", dateList.ToArray ()) + ")";
+					expressionList.Add (date);
+				// Using translated tokens
+				} else
+					expressionList.Add (GetFormatedToken (match));
+			}
+			return String.Join (@"\s+", expressionList.ToArray ());
+		}
+
+		string GetFormatedToken (Match match)
+		{
+			// It's a translatable token, we need it named.
+			if (match.Value.Length == 1) {
+				char token = match.Value [0];
+				string savedTokens = translatableTokens [token];
+				return string.Format (@"(?<{0}>\b({1})\b)", token, savedTokens);
+			// It's a "hardcoded" translated string. We need the complete word
+			} else
+				return string.Format (@"({0})", match.Value.Replace ("'", @"\b"));
+		}
+
+		// Based on the Fields decorated with "RegularToken" in
+		// RegularExpressions class we create a Dictionary to keep the
+		// Key="character token" and its Value="tokens to match".
+		void FillTranslatableTokens ()
+		{
+			translatableTokens = new Dictionary<char, string> ();
+			
+			FieldInfo[] fields
+				= typeof (RegularExpressions).GetFields (BindingFlags.Static
+				                                         | BindingFlags.Public);
+			foreach (FieldInfo field in fields) {
+				object[] attributes = field.GetCustomAttributes (false);
+				if (attributes.Length == 0)
+					continue;
+
+				// We know our attribute is not AllowMultiple, so there's
+				// always one.
+				RegularTokenAttribute tokenAttribute
+					= attributes [0] as RegularTokenAttribute;
+				if (tokenAttribute == null)
+					continue;
+
+				string expression = field.GetValue (null) as string;
+				if (expression == null)
+					throw new ArgumentException (string.Format ("Field is not string: '{0}'",
+					                                             field.Name));
+
+				// We DON'T want to use [], we want to crash if something 
+				// is duplicated.
+				translatableTokens.Add (tokenAttribute.Token,
+				                        expression.Replace (" ", @"\s+"));
+			}
+		}
+
+		List<RegularExpressionFormat> GetRegularExpressions ()
+		{
+			List<RegularExpressionFormat> regularExpressions
+				= new List<RegularExpressionFormat> ();
+			FieldInfo[] fields
+				= typeof (RegularExpressions).GetFields (BindingFlags.Static
+				                                         | BindingFlags.Public);
+			foreach (FieldInfo field in fields) {
+				object[] attributes = field.GetCustomAttributes (false);
+				if (attributes.Length == 0)
+					continue;
+
+				// We know our attribute is not AllowMultiple, so there's
+				// always one.
+				RegularExpressionAttribute regAttribute
+					= attributes [0] as RegularExpressionAttribute;
+				if (regAttribute == null)
+					continue;
+
+				string expression = field.GetValue (null) as string;
+				if (expression == null)
+					throw new ArgumentException (string.Format ("Field is not string: '{0}'",
+					                                             field.Name));
+
+				foreach (string alternativeExpression 
+				         in GetAlternativesExpressions (expression)) {
+					// FIXME: Use a Factory class to reuse IDateFormatter instance
+					IDateFormatter formater
+						= (IDateFormatter) Activator.CreateInstance (regAttribute.FormatterType);
+					regularExpressions.Add (new RegularExpressionFormat (alternativeExpression,
+					                                                     regAttribute.FormatExpression,
+					                                                     formater));
+				}
+			}
+			return regularExpressions;
+		}
+
+		// Spliting all "|" separated expressions
+		List<string> GetAlternativesExpressions (string expression)
+		{
+			List<string> expressionList = new List<string> ();
+			Regex regex = new Regex (AlternativesExpression, 
+			                         RegexOptions.IgnoreCase);
+			foreach (Match match in regex.Matches (expression))
+				expressionList.Add (match.Value);
+			return expressionList;
+		}
+
+		string fullExpression;
+		List<RegularExpressionFormat> regExFormats;
+		Dictionary<char, string> translatableTokens;
+	}
+}
diff --git a/src/libtasque/Utilities.cs b/src/libtasque/Utilities.cs
new file mode 100644
index 0000000..0abaddb
--- /dev/null
+++ b/src/libtasque/Utilities.cs
@@ -0,0 +1,55 @@
+
+using System;
+using Mono.Unix;
+
+namespace Tasque {
+
+	// TODO: Change this class to internal
+	public static partial class Utilities {
+
+		public static string GetLocalizedDayOfWeek (DayOfWeek dayOfWeek)
+		{
+			switch (dayOfWeek) {
+			case DayOfWeek.Sunday:
+				return Catalog.GetString ("Sunday");
+			case DayOfWeek.Monday:
+				return Catalog.GetString ("Monday");
+			case DayOfWeek.Tuesday:
+				return Catalog.GetString ("Tuesday");
+			case DayOfWeek.Wednesday:
+				return Catalog.GetString ("Wednesday");
+			case DayOfWeek.Thursday:
+				return Catalog.GetString ("Thursday");
+			case DayOfWeek.Friday:
+				return Catalog.GetString ("Friday");
+			case DayOfWeek.Saturday:
+				return Catalog.GetString ("Saturday");
+			}
+
+			return string.Empty;
+		}
+
+		public static string GetLocalizedDayOfWeekShort (DayOfWeek dayOfWeek)
+		{
+			switch (dayOfWeek) {
+			case DayOfWeek.Sunday:
+				return Catalog.GetString ("Sun");
+			case DayOfWeek.Monday:
+				return Catalog.GetString ("Mon");
+			case DayOfWeek.Tuesday:
+				return Catalog.GetString ("Tue");
+			case DayOfWeek.Wednesday:
+				return Catalog.GetString ("Wed");
+			case DayOfWeek.Thursday:
+				return Catalog.GetString ("Thu");
+			case DayOfWeek.Friday:
+				return Catalog.GetString ("Fri");
+			case DayOfWeek.Saturday:
+				return Catalog.GetString ("Sat");
+			}
+
+			return string.Empty;
+		}
+
+	}
+}
diff --git a/src/libtasque/libtasque.csproj b/src/libtasque/libtasque.csproj
index 3eb06e4..e579a7d 100644
--- a/src/libtasque/libtasque.csproj
+++ b/src/libtasque/libtasque.csproj
@@ -7,9 +7,9 @@
     <SchemaVersion>2.0</SchemaVersion>
     <ProjectGuid>{784C9AA8-2B28-400B-8CC4-DCDC48CA37F0}</ProjectGuid>
     <OutputType>Library</OutputType>
-    <RootNamespace>libtasque</RootNamespace>
+    <RootNamespace>Tasque</RootNamespace>
     <AssemblyName>libtasque</AssemblyName>
-    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -35,9 +35,39 @@
     <Compile Include="ITask.cs" />
     <Compile Include="TaskPriority.cs" />
     <Compile Include="TaskState.cs" />
+    <Compile Include="DateGuesser.cs" />
+    <Compile Include="Utilities.cs" />
+    <Compile Include="DateGuessers\IDateGuesser.cs" />
+    <Compile Include="DateGuessers\TomorrowTodayGuesser.cs" />
+    <Compile Include="DateGuessers\NextGuesser.cs" />
+    <Compile Include="DateGuessers\DueGuesser.cs" />
+    <Compile Include="Constants.cs" />
+    <Compile Include="DateGuessers\OnGuesser.cs" />
+    <Compile Include="TaskParser.cs" />
+    <Compile Include="RegularTokenAttribute.cs" />
+    <Compile Include="RegularExpressions.cs" />
+    <Compile Include="RegularExpressionAttribute.cs" />
   </ItemGroup>
   <ItemGroup>
     <Reference Include="gtk-sharp, Version=2.12.0.0, Culture=neutral, PublicKeyToken=35e10195dab3c99f" />
     <Reference Include="System" />
+    <Reference Include="System.Core" />
+    <Reference Include="Mono.Posix, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756">
+      <SpecificVersion>False</SpecificVersion>
+      <HintPath>..\..\winbin\Mono.Posix.dll</HintPath>
+    </Reference>
   </ItemGroup>
+  <ItemGroup>
+    <Folder Include="DateGuessers\" />
+  </ItemGroup>
+  <ProjectExtensions>
+    <MonoDevelop>
+      <Properties>
+        <Policies>
+          <DotNetNamingPolicy DirectoryNamespaceAssociation="PrefixedHierarchical" ResourceNamePolicy="MSBuild" />
+          <StandardHeader Text="Author:&#xA;      ${AuthorName} &lt;${AuthorEmail}&gt;&#xA;&#xA;Copyright (c) ${Year} ${CopyrightHolder}&#xA;&#xA;Permission is hereby granted, free of charge, to any person obtaining a copy&#xA;of this software and associated documentation files (the &quot;Software&quot;), to deal&#xA;in the Software without restriction, including without limitation the rights&#xA;to use, copy, modify, merge, publish, distribute, sublicense, and/or sell&#xA;copies of the Software, and to permit persons to whom the Software is&#xA;furnished to do so, subject to the following conditions:&#xA;&#xA;The above copyright notice and this permission notice shall be included in&#xA;all copies or substantial portions of the Software.&#xA;&#xA;THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR&#xA;IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,&#xA;FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE&#xA;AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER&#xA;LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,&#xA;OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN&#xA;THE SOFTWARE." inheritsSet="MITX11License" />
+        </Policies>
+      </Properties>
+    </MonoDevelop>
+  </ProjectExtensions>
 </Project>
\ No newline at end of file
diff --git a/tasque.csproj b/tasque.csproj
index d71b608..c1eddd3 100644
--- a/tasque.csproj
+++ b/tasque.csproj
@@ -9,7 +9,7 @@
     <OutputType>WinExe</OutputType>
     <NoStandardLibraries>false</NoStandardLibraries>
     <AssemblyName>tasque</AssemblyName>
-    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
     <FileAlignment>512</FileAlignment>
     <NoWin32Manifest>True</NoWin32Manifest>
     <RootNamespace>tasque</RootNamespace>
diff --git a/tasque.sln b/tasque.sln
index 4e9c7c6..10413d0 100644
--- a/tasque.sln
+++ b/tasque.sln
@@ -7,6 +7,8 @@ Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "RtmNet", "RtmNet\RtmNet.csp
 EndProject
 Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "libtasque", "src\libtasque\libtasque.csproj", "{784C9AA8-2B28-400B-8CC4-DCDC48CA37F0}"
 EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "tests", "tests\tests.csproj", "{6DC908EC-E7C2-46CD-A21D-832C0D81D946}"
+EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
 		Debug|Any CPU = Debug|Any CPU
@@ -17,6 +19,10 @@ Global
 		{0AA1B96E-03DE-4D26-B4FD-507E988FD9B7}.Debug|Any CPU.Build.0 = Debug|Any CPU
 		{0AA1B96E-03DE-4D26-B4FD-507E988FD9B7}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{0AA1B96E-03DE-4D26-B4FD-507E988FD9B7}.Release|Any CPU.Build.0 = Release|Any CPU
+		{6DC908EC-E7C2-46CD-A21D-832C0D81D946}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{6DC908EC-E7C2-46CD-A21D-832C0D81D946}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{6DC908EC-E7C2-46CD-A21D-832C0D81D946}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{6DC908EC-E7C2-46CD-A21D-832C0D81D946}.Release|Any CPU.Build.0 = Release|Any CPU
 		{784C9AA8-2B28-400B-8CC4-DCDC48CA37F0}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{784C9AA8-2B28-400B-8CC4-DCDC48CA37F0}.Debug|Any CPU.Build.0 = Debug|Any CPU
 		{784C9AA8-2B28-400B-8CC4-DCDC48CA37F0}.Release|Any CPU.ActiveCfg = Release|Any CPU
diff --git a/tests/DateGuesserTest.cs b/tests/DateGuesserTest.cs
new file mode 100644
index 0000000..c05a8e0
--- /dev/null
+++ b/tests/DateGuesserTest.cs
@@ -0,0 +1,354 @@
+//
+// Author:
+//      Mario Carrion <mario@carrion.mx>
+//
+// Copyright (c) 2010 Mario Carrion
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+using NUnit.Framework;
+
+using Tasque;
+
+namespace Tasque.Tests {
+
+	[TestFixture]
+	public class DateGuesserTest {
+		
+		#region TomorrowTodayGuesser
+
+		[Test]
+		public void Today ()
+		{
+			DateGuesser guesser = DateGuesser.Instance;
+			
+			DateTime dateTime = DateTime.MinValue;
+			DateTime expected = DateTime.Today;
+			string task = string.Empty;
+			string text = string.Empty;
+
+			// #1
+			text = string.Format ("Sell something, {0}, on the internet", 
+			                       Constants.Today);
+			bool parsed = guesser.Parse (text, out task, out dateTime);
+			Assert.IsTrue (parsed, "#0");
+			Assert.AreEqual ("Sell something,, on the internet", task, "#1");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#2");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#3");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#4");
+			parsed = false;
+			dateTime = DateTime.MinValue;
+
+			// #2
+			text = string.Format ("Buy beer {0}", Constants.Today);
+			parsed = guesser.Parse (text, out task, out dateTime);
+			Assert.IsTrue (parsed, "#5");
+			Assert.AreEqual ("Buy beer", task, "#6");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#7");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#8");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#9");
+			parsed = false;
+			dateTime = DateTime.MinValue;
+			
+			// Due is separated by "|"
+			string[] dues = Constants.Due.Split (new string[] { "|" }, 
+			                                     StringSplitOptions.RemoveEmptyEntries);
+			foreach (string due in dues) {
+				if (string.IsNullOrEmpty (due))
+					continue;
+
+				// #3
+				text = string.Format ("Print tickets {0} {1}", due, Constants.Today);
+				parsed = guesser.Parse (text, out task, out dateTime);
+				Assert.IsTrue (parsed, "#10");
+				Assert.AreEqual ("Print tickets", 
+				                 task, 
+				                 string.Format ("#11 -> {0}", due));
+				Assert.AreEqual (expected.Month,
+				                 dateTime.Month, 
+				                 string.Format ("#12 -> {0}", due));
+				Assert.AreEqual (expected.Day, 
+				                 dateTime.Day, 
+				                 string.Format ("#13 -> {0}", due));
+				Assert.AreEqual (expected.Year, 
+				                 dateTime.Year, 
+				                 string.Format ("#14 -> {0}", due));
+				parsed = false;
+				dateTime = DateTime.MinValue;
+			}
+		}
+		
+		[Test]
+		public void Tomorrow ()
+		{
+			DateGuesser guesser = DateGuesser.Instance;
+			
+			DateTime dateTime = DateTime.MinValue;
+			DateTime expected = DateTime.Today.AddDays (1);
+			string task = string.Empty;
+			string text = string.Empty;
+
+			// #1
+			text = string.Format ("Sell something, {0}, on the internet", 
+			                       Constants.Tomorrow);
+			bool parsed = guesser.Parse (text, out task, out dateTime);
+			Assert.IsTrue (parsed, "#0");
+			Assert.AreEqual ("Sell something,, on the internet", task, "#1");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#2");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#3");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#4");
+			parsed = false;
+			dateTime = DateTime.MinValue;
+
+			// #2
+			text = string.Format ("Buy beer {0}", Constants.Tomorrow);
+			parsed = guesser.Parse (text, out task, out dateTime);
+			Assert.IsTrue (parsed, "#5");
+			Assert.AreEqual ("Buy beer", task, "#6");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#7");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#8");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#9");
+			parsed = false;
+			dateTime = DateTime.MinValue;
+			
+			// Due is separated by "|"
+			string[] dues = Constants.Due.Split (new string[] { "|" }, 
+			                                     StringSplitOptions.RemoveEmptyEntries);
+			foreach (string due in dues) {
+				if (string.IsNullOrEmpty (due))
+					continue;
+
+				// #3
+				text = string.Format ("Print tickets {0} {1}", due, Constants.Tomorrow);
+				parsed = guesser.Parse (text, out task, out dateTime);
+				Assert.IsTrue (parsed, "#10");
+				Assert.AreEqual ("Print tickets", 
+				                 task, 
+				                 string.Format ("#11 -> {0}", due));
+				Assert.AreEqual (expected.Month,
+				                 dateTime.Month, 
+				                 string.Format ("#12 -> {0}", due));
+				Assert.AreEqual (expected.Day, 
+				                 dateTime.Day, 
+				                 string.Format ("#13 -> {0}", due));
+				Assert.AreEqual (expected.Year, 
+				                 dateTime.Year, 
+				                 string.Format ("#14 -> {0}", due));
+				parsed = false;
+				dateTime = DateTime.MinValue;
+			}
+		}
+
+		#endregion
+
+		#region NextGuesser
+		
+		[Test]
+		public void NextMonth ()
+		{
+			DateTime dateTime = DateTime.MinValue;
+			string task = string.Empty;
+
+			DateTime expected = DateTime.Today.AddMonths (1);
+			string text = string.Format ("Sell something, {0} {1}, on the internet", 
+			                              Constants.Next, 
+			                              Constants.Month);
+			Assert.IsTrue (DateGuesser.Instance.Parse (text, out task, out dateTime), "#0");
+			Assert.AreEqual ("Sell something,, on the internet", task, "#1");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#2");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#3");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#4");
+		}
+
+		[Test]
+		public void NextWeek ()
+		{
+			DateTime dateTime = DateTime.MinValue;
+			string task = string.Empty;
+			DateTime expected = DateTime.Today.AddDays (7);
+
+			string text = string.Format ("Buy beer {0} {1}",
+			                              Constants.Next,
+			                              Constants.Week);
+			Assert.IsTrue (DateGuesser.Instance.Parse (text, out task, out dateTime), "#1");
+			Assert.AreEqual ("Buy beer", task, "#2");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#3");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#4");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#5");
+		}
+		
+		[Test]
+		public void NextYear ()
+		{
+			DateTime dateTime = DateTime.MinValue;
+			string task = string.Empty;
+
+			DateTime expected = DateTime.Today.AddYears (1);
+			string text = string.Format ("Buy a house {0} {1}",
+			                              Constants.Next,
+			                              Constants.Year);
+			Assert.IsTrue (DateGuesser.Instance.Parse (text, out task, out dateTime), "#1");
+			Assert.AreEqual ("Buy a house", task, "#2");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#3");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#4");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#5");
+		}
+
+		[Test]
+		public void NextMonday ()
+		{
+			DateTime dateTime = DateTime.MinValue;
+			string task = string.Empty;
+
+			DateTime expected = DateTime.Today.AddDays (GetDayOffset (DayOfWeek.Monday));
+			string text = string.Format ("Doctor appointment {0} {1}", 
+			                             Constants.Next, 
+			                             Utilities.GetLocalizedDayOfWeek (DayOfWeek.Monday));
+			Assert.IsTrue (DateGuesser.Instance.Parse (text, out task, out dateTime), "#0");
+			Assert.AreEqual ("Doctor appointment", task, "#1");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#2");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#3");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#4");
+		}
+
+		[Test]
+		public void OnNextMonday ()
+		{
+			DateTime dateTime = DateTime.MinValue;
+			string task = string.Empty;
+
+			DateTime expected = DateTime.Today.AddDays (GetDayOffset (DayOfWeek.Monday));
+			string text = string.Format ("Doctor appointment {0} {1} {2}",
+			                             Constants.On,
+			                             Constants.Next,
+			                             Utilities.GetLocalizedDayOfWeek (DayOfWeek.Monday));
+			Assert.IsTrue (DateGuesser.Instance.Parse (text, out task, out dateTime), "#0");
+			Assert.AreEqual ("Doctor appointment", task, "#1");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#2");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#3");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#4");
+		}
+
+		#endregion
+		
+		#region DueGuesser 
+		
+		[Test]
+		public void DueValid ()
+		{
+			DateGuesser guesser = DateGuesser.Instance;
+			
+			DateTime dateTime = DateTime.MinValue;
+			DateTime expected = DateTime.MinValue;
+			string task = string.Empty;
+
+			// January
+			string text = string.Format ("Sell something due {0} 12", Constants.Months [0]);
+			expected = GetMonthDate (1, 12);
+
+			Assert.IsTrue (guesser.Parse (text, out task, out dateTime), "#0");
+			Assert.AreEqual ("Sell something", task, "#1");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#2");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#3");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#4");
+			dateTime = DateTime.MinValue;
+
+			// April 22
+			expected = GetMonthDate (4, 22);
+			text = string.Format ("Sell something due {0} 22nd", Constants.Months [7]);
+
+			Assert.IsTrue (guesser.Parse (text, out task, out dateTime), "#5");
+			Assert.AreEqual ("Sell something", task, "#6");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#7");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#8");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#9");
+			dateTime = DateTime.MinValue;
+
+			// April 13th
+			expected = GetMonthDate (4, 13);
+			text = string.Format ("Sell something due {0} 13th", Constants.Months [7]);
+
+			Assert.IsTrue (guesser.Parse (text, out task, out dateTime), "#10");
+			Assert.AreEqual ("Sell something", task, "#11");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#12");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#13");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#14");
+			dateTime = DateTime.MinValue;
+			
+			// May
+			expected = GetMonthDate (5, 1);
+			text = string.Format ("Sell something due before {0}", Constants.Months [9]);
+
+			Assert.IsTrue (guesser.Parse (text, out task, out dateTime), "#15");
+			Assert.AreEqual ("Sell something", task, "#16");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#17");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#18");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#19");
+		}
+		
+		[Test]
+		public void DueInvalid ()
+		{
+			string task = string.Empty;
+			DateTime dateTime = DateTime.MinValue;
+			
+			// April 22rd - invalid
+			string text = string.Format ("Sell something due {0} 22rd", Constants.Months [7]);
+			Assert.IsFalse (DateGuesser.Instance.Parse (text, 
+			                                            out task,
+			                                            out dateTime), 
+			                "#10");
+
+			// April 32nd
+			text = string.Format ("Sell something due {0} 32nd", Constants.Months [7]);
+			Assert.IsFalse (DateGuesser.Instance.Parse (text, 
+			                                            out task, 
+			                                            out dateTime), 
+			                "#10");
+		}
+
+		#endregion
+
+		#region Helper methods
+
+		DateTime GetMonthDate (int month, int day)
+		{
+			if (DateTime.Now.Month > month)
+				return new DateTime (DateTime.Now.Year + 1, month, day);
+			else
+				return new DateTime (DateTime.Now.Year, month, day);
+		}
+
+		uint GetDayOffset (DayOfWeek futureDay)
+		{
+			uint future = DateGuesser.DayOfWeekToUInt (futureDay);
+			uint today = DateGuesser.DayOfWeekToUInt (DateTime.Today.DayOfWeek);
+			
+			if (future > today)
+				return future - today;
+			else if (today > future)
+				return 7 - (today - future);
+			else
+				return 7;
+		}
+
+		#endregion
+	}
+}
diff --git a/tests/TaskParserFixture.cs b/tests/TaskParserFixture.cs
new file mode 100644
index 0000000..9801aa6
--- /dev/null
+++ b/tests/TaskParserFixture.cs
@@ -0,0 +1,19 @@
+
+using System;
+using NUnit.Framework;
+
+namespace Tasque.Tests {
+
+	[TestFixture]
+	public class TaskParserFixture {
+
+		[Test]
+		public void TestCase ()
+		{
+			TaskParser p = new TaskParser ();
+			string regEx = p.GenerateRegularExpression (@"u n \'de' T\");
+
+			Console.WriteLine ("RegEx: {0}", regEx);
+		}
+	}
+}
diff --git a/tests/tests.csproj b/tests/tests.csproj
new file mode 100644
index 0000000..fe3dffb
--- /dev/null
+++ b/tests/tests.csproj
@@ -0,0 +1,46 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="3.5" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.21022</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{6DC908EC-E7C2-46CD-A21D-832C0D81D946}</ProjectGuid>
+    <OutputType>Library</OutputType>
+    <RootNamespace>Tasque.Tests</RootNamespace>
+    <AssemblyName>tasque.tests</AssemblyName>
+    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>bin\Debug</OutputPath>
+    <DefineConstants>DEBUG</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>none</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>bin\Release</OutputPath>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="nunit.core, Version=2.4.8.0, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77" />
+    <Reference Include="nunit.framework, Version=2.4.8.0, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="DateGuesserTest.cs" />
+    <Compile Include="TaskParserFixture.cs" />
+  </ItemGroup>
+  <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
+  <ItemGroup>
+    <ProjectReference Include="..\src\libtasque\libtasque.csproj">
+      <Project>{784C9AA8-2B28-400B-8CC4-DCDC48CA37F0}</Project>
+      <Name>libtasque</Name>
+    </ProjectReference>
+  </ItemGroup>
+</Project>
\ No newline at end of file
