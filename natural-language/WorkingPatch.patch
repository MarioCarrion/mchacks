diff --git a/RtmNet/RtmNet.csproj b/RtmNet/RtmNet.csproj
index 127a70a..145e4e8 100644
--- a/RtmNet/RtmNet.csproj
+++ b/RtmNet/RtmNet.csproj
@@ -9,7 +9,7 @@
     <OutputType>Library</OutputType>
     <NoStandardLibraries>false</NoStandardLibraries>
     <AssemblyName>RtmNet</AssemblyName>
-    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
     <FileAlignment>512</FileAlignment>
     <RootNamespace>RtmNet</RootNamespace>
   </PropertyGroup>
diff --git a/TRANSLATORS b/TRANSLATORS
new file mode 100644
index 0000000..deb9bdf
--- /dev/null
+++ b/TRANSLATORS
@@ -0,0 +1,56 @@
+TRANSLATORS
+
+All translatable strings refering to this file mean the following.
+
+NOTES
+
+- Don't remove the the vertical separator or pipe ('|') in strings
+  containing it. Only the elements separated by this character are
+  translated. Also do not add extra spaces. For example:
+  "Jan|January|Feb" translated to spanish "Ene|Enero|Feb"
+  
+ORDINAL NUMBERS and ORDINAL SUFIXES
+
+To get a valid ordinal numbers two rules are needed:
+	1. A number and a suffix, for example "1" and "st"
+	2. A valid suffix for the number.
+ 
+For example, in English, valid ordinal numbers are: 1st, 2nd and 3rd,
+invalid ordinal numbers are: 1rd, 2st, 3th.
+
+In order to match a *valid* ordinal number you will to translate the
+"OrdinalNumbers" string. By default, in English, its value is the
+following: 
+	"11|12|13=th,1=st,2=nd,3=rd,default=th"
+
+  This means the following:
+  - ONLY numbers "11", "12" and "13" will have a "th" suffix,
+  - Numbers ending with 1 will have a "st" suffix.
+  - Numbers ending with 2 will have a "nd" suffix.
+  - Numbers ending with 3 will have a "rd" suffix.
+  - All other numbers will have to have "th" as suffix.
+
+To translate to your language you have to ALWAYS define a default value
+and the specific values, if any, in English the specific values are 
+"11th", "12th" and "13th". The default string could also be written as:
+
+	"11=th,12=th,13=th,1=st,2=nd,3=rd,default=th"
+
+TRANSLATABLE EXPRESSIONS
+
+-------------------------------------------------------------
+| Token | English words           | Description
+-------------------------------------------------------------
+| M     | "Jan|January|Feb|..."   | Short and long months.
+| D     | "Sun|Sunday|Mon|..."    | Short and long weekdays.
+| T     | "today", "tomorrow"     | Same.
+| O     | "1st,2nd,3rd,11th,.."   | Ordinal number
+| N     | "1,2,3,11,.."           | Cardinal number, beginning in 1.
+
+| u     | "due|due by|due before" | Same
+| w     | "week|weeks"            | Same
+| m     | "month|months"          | Same
+| y     | "year|years"            | Same
+| n     | "next"                  | Same
+| o     | "on"                    | Same
+| i     | "in"                    | Same
\ No newline at end of file
diff --git a/src/Makefile.am b/src/Makefile.am
index 667b131..68e0c4a 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -83,12 +83,7 @@ CSFILES = \
 	$(srcdir)/TaskWindow.cs \
 	$(srcdir)/TaskTreeView.cs \
 	$(srcdir)/Utilities.cs \
-	$(srcdir)/libtasque/IBackend.cs \
-	$(srcdir)/libtasque/ICategory.cs \
-	$(srcdir)/libtasque/ITask.cs \
-	$(srcdir)/libtasque/INote.cs \
-	$(srcdir)/libtasque/TaskPriority.cs \
-	$(srcdir)/libtasque/TaskState.cs \
+	$(TASQUEDLL_CSFILES) \
 	\
 	$(DUMMY_CSFILES) \
 	\
@@ -102,6 +97,34 @@ CSFILES = \
 	\
 	$(HIVEMINDER_CSFILES)
 
+TASQUEDLL_CSFILES = \
+	$(srcdir)/libtasque/DateFormatterFactory.cs \
+	$(srcdir)/libtasque/IBackend.cs \
+	$(srcdir)/libtasque/ICategory.cs \
+	$(srcdir)/libtasque/INote.cs \
+	$(srcdir)/libtasque/ITask.cs \
+	$(srcdir)/libtasque/RegularExpressionAttribute.cs \
+	$(srcdir)/libtasque/RegularExpressionFormatter.cs \
+	$(srcdir)/libtasque/RegularExpressions.cs \
+	$(srcdir)/libtasque/TaskParser.cs \
+	$(srcdir)/libtasque/TaskPriority.cs \
+	$(srcdir)/libtasque/TaskState.cs \
+	$(srcdir)/libtasque/TokenAttribute.cs \
+	$(srcdir)/libtasque/TranslatableToken.cs \
+	$(foreach file,$(TASQUEDLL_FORMATTERS_CSFILES), $(addprefix $(srcdir)/libtasque/DateFormatters/, $(file)))
+
+TASQUEDLL_FORMATTERS_CSFILES = \
+	DateFormatter.cs \
+	IDateFormatter.cs \
+	MonthFormatter.cs \
+	OrdinalFormatter.cs \
+	QuantityFormatter.cs \
+	StringInsensitiveComparer.cs \
+	TodayTomorrowFormatter.cs \
+	WeekdayFormatter.cs \
+	WeekFormatter.cs \
+	YearFormatter.cs
+
 RESOURCES = \
 	-resource:$(top_srcdir)/data/images/tasque-16.png \
 	-resource:$(top_srcdir)/data/images/tasque-22.png \
@@ -125,6 +148,7 @@ RESOURCES = \
 
 ASSEMBLIES =  \
 	-r:System \
+	-r:System.Core \
 	-r:Mono.Posix \
 	-r:System.Xml \
 	-r:System.Web \
@@ -186,6 +210,7 @@ EXTRA_DIST = \
 	$(srcdir)/Backends/Hiveminder/*.cs \
 	$(srcdir)/Backends/Hiveminder/service/*.cs \
 	$(srcdir)/libtasque/*.cs \
+	$(srcdir)/libtasque/DateFormatters/* \
 	$(srcdir)/libtasque/libtasque.csproj
 
 pkgconfigdir = $(libdir)/pkgconfig
diff --git a/src/RemoteControl.cs b/src/RemoteControl.cs
index 34b9277..3681960 100644
--- a/src/RemoteControl.cs
+++ b/src/RemoteControl.cs
@@ -120,7 +120,7 @@ namespace Tasque
 			// out of the taskName.
 			DateTime taskDueDate = DateTime.MinValue;
 			if (parseDate && Application.Preferences.GetBool (Preferences.ParseDateEnabledKey))
-				Utilities.ParseTaskText (
+				TaskParser.Instance.TryParse (
 				                         taskName,
 				                         out taskName,
 				                         out taskDueDate);
diff --git a/src/TaskTreeView.cs b/src/TaskTreeView.cs
index 202ca61..8511ff7 100644
--- a/src/TaskTreeView.cs
+++ b/src/TaskTreeView.cs
@@ -640,7 +640,7 @@ namespace Tasque
 				
 				string parsedTaskText;
 				DateTime parsedDueDate;
-				Utilities.ParseTaskText (newText, out parsedTaskText, out parsedDueDate);
+				TaskParser.Instance.TryParse (newText, out parsedTaskText, out parsedDueDate);
 				
 				if (parsedDueDate != DateTime.MinValue)
 					task.DueDate = parsedDueDate;
diff --git a/src/TaskWindow.cs b/src/TaskWindow.cs
index e51c221..eaedaf4 100644
--- a/src/TaskWindow.cs
+++ b/src/TaskWindow.cs
@@ -952,7 +952,7 @@ namespace Tasque
 			DateTime taskDueDate = DateTime.MinValue;
 			string taskName;
 			if (Application.Preferences.GetBool (Preferences.ParseDateEnabledKey))
-				Utilities.ParseTaskText (
+				TaskParser.Instance.TryParse (
 				                         enteredTaskText,
 				                         out taskName,
 				                         out taskDueDate);
diff --git a/src/Utilities.cs b/src/Utilities.cs
index a5e26fe..ac5135e 100644
--- a/src/Utilities.cs
+++ b/src/Utilities.cs
@@ -2,9 +2,11 @@
  *  Utilities.cs
  *
  *  Copyright (C) 2007 Novell, Inc.
+ *  Copyright (C) 2010 Mario Carrion
  *  Written by:
  * 		Calvin Gaisford <calvinrg@gmail.com>
  *		Boyd Timothy <btimothy@gmail.com>
+ * 		Mario Carrion <mario@carrion.mx>
  ****************************************************************************/
 
 /*  THIS FILE IS LICENSED UNDER THE MIT LICENSE AS OUTLINED IMMEDIATELY BELOW: 
@@ -41,7 +43,8 @@ using Gtk;
 
 namespace Tasque
 {
-	internal class Utilities
+	// TODO: Change this class to internal
+	public static partial class Utilities
 	{
 		public static string ReplaceString (string originalString, string searchString, string replaceString)
 		{
@@ -310,102 +313,6 @@ namespace Tasque
 
 			return pretty_str;
 		}
-		
-		public static string GetLocalizedDayOfWeek (System.DayOfWeek dayOfWeek)
-		{
-			switch (dayOfWeek) {
-			case DayOfWeek.Sunday:
-				return Catalog.GetString ("Sunday");
-			case DayOfWeek.Monday:
-				return Catalog.GetString ("Monday");
-			case DayOfWeek.Tuesday:
-				return Catalog.GetString ("Tuesday");
-			case DayOfWeek.Wednesday:
-				return Catalog.GetString ("Wednesday");
-			case DayOfWeek.Thursday:
-				return Catalog.GetString ("Thursday");
-			case DayOfWeek.Friday:
-				return Catalog.GetString ("Friday");
-			case DayOfWeek.Saturday:
-				return Catalog.GetString ("Saturday");
-			}
-			
-			return string.Empty;
-		}
-		
-		/// <summary>
-		/// Parse the task name in order to derive due date information.
-		/// </summary>
-		/// <param name="enteredTaskText">
-		/// A <see cref="System.String"/> representing the text entered
-		/// into the task name field.
-		/// </param>
-		/// <param name="parsedTaskText">
-		/// The enteredTaskText with the due date section of the string
-		/// removed.
-		/// </param>
-		/// <param name="parsedDueDate">
-		/// The due date derived from enteredTaskText, or
-		/// DateTime.MinValue if no date information was found.
-		/// </param>
-		public static void ParseTaskText (string enteredTaskText, out string parsedTaskText, out DateTime parsedDueDate)
-		{
-			// First, look for ways that the right side of the entered
-			// text can be directly parsed as a date
-			string[] words = enteredTaskText.Split (' ');
-			for (int i = 1; i < words.Length; i++) {
-				string possibleDate = string.Join (" ", words, i, words.Length - i);
-				DateTime result;
-				if (DateTime.TryParse (possibleDate, out result)) {
-					// Favor future dates, unless year was specifically mentioned
-					if (!possibleDate.Contains (result.Year.ToString ()))
-						while (result < DateTime.Today)
-							result = result.AddYears (1);
-					
-					// Set task due date and return the task
-					// name with the date part removed.
-					parsedDueDate = result;
-					parsedTaskText = string.Join (" ", words, 0, i);
-					return;
-				}
-			}
-			
-			// Then try some more natural language parsing
-			
-			// A regular expression to capture a task that is due today
-			string today = Catalog.GetString (@"^(?<task>.+)\s+today\W*$");
-			// A regular expression to capture a task that is due tomorrow
-			string tomorrow = Catalog.GetString (@"^(?<task>.+)\s+tomorrow\W*$");
-			
-			// Additional regular expressions to consider using
-			//string abbrevDate = Catalog.GetString (@"^(?<task>.+)(on )?(the )?(?<day>\d{1,2})((th)|(nd)|(rd)|(st))\W*$");
-			//string nextDayName = Catalog.GetString (@"^(?<task>.+)(on )?next\s+(?<day>[a-z]+)\W*$");
-			//string dayName = Catalog.GetString (@"^(?<task>.+)\s+(on )?(?<day>[a-z]+)\W*$");
-			
-			Match match = Regex.Match (enteredTaskText, today, RegexOptions.IgnoreCase);
-			if (match.Success) {
-				string trimmedTaskText = match.Groups ["task"].Value;
-				if (!string.IsNullOrEmpty (trimmedTaskText)) {
-					parsedDueDate = DateTime.Now;
-					parsedTaskText = trimmedTaskText;
-					return;
-				}
-			}
-			
-			match = Regex.Match (enteredTaskText, tomorrow, RegexOptions.IgnoreCase);
-			if (match.Success) {
-				string trimmedTaskText = match.Groups ["task"].Value;
-				if (!string.IsNullOrEmpty (trimmedTaskText)) {
-					parsedDueDate = DateTime.Now.AddDays (1);
-					parsedTaskText = trimmedTaskText;
-					return;
-				}
-			}
-			
-			parsedTaskText = enteredTaskText;
-			parsedDueDate = DateTime.MinValue;
-			return;
-		}
 
 		/// <summary>
 		/// This returns the hexadecimal value of an GDK color.
diff --git a/src/libtasque/DateFormatterFactory.cs b/src/libtasque/DateFormatterFactory.cs
new file mode 100644
index 0000000..825b180
--- /dev/null
+++ b/src/libtasque/DateFormatterFactory.cs
@@ -0,0 +1,55 @@
+// Author:
+//       Mario Carrion <mario@carrion.mx>
+// 
+// Copyright (c) 2010 Mario Carrion
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+using System.Reflection;
+using System.Collections.Generic;
+using Tasque.DateFormatters;
+
+namespace Tasque {
+
+	sealed class DateFormatterFactory {
+
+		public static readonly DateFormatterFactory Instance = new DateFormatterFactory ();
+
+		private DateFormatterFactory ()
+		{
+			dateFormatters = new Dictionary<Type, IDateFormatter>();
+		}
+
+		public IDateFormatter Get (Type type)
+		{
+			IDateFormatter formatter = null;
+			if (dateFormatters.TryGetValue (type, out formatter))
+				return formatter;
+			else {
+				// We want to crash if Type is not IDateFormatter
+				formatter = (IDateFormatter) Activator.CreateInstance (type);
+				dateFormatters [type] = formatter;
+				return formatter;
+			}
+		}
+
+		Dictionary<Type, IDateFormatter> dateFormatters;
+	}
+}
diff --git a/src/libtasque/DateFormatters/DateFormatter.cs b/src/libtasque/DateFormatters/DateFormatter.cs
new file mode 100644
index 0000000..c57749c
--- /dev/null
+++ b/src/libtasque/DateFormatters/DateFormatter.cs
@@ -0,0 +1,77 @@
+// Author:
+//       Mario Carrion <mario@carrion.mx>
+// 
+// Copyright (c) 2010 Mario Carrion
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+using System.Text.RegularExpressions;
+
+using Tasque;
+
+namespace Tasque.DateFormatters {
+
+	class DateFormatter : IDateFormatter {
+		
+		// Formatting: Month and OrdinalNumber
+		public DateTime GetDate (Match match)
+		{
+			bool dayProvided = !string.IsNullOrEmpty (match.Groups ["O"].Value);
+			bool monthProvided = !string.IsNullOrEmpty (match.Groups ["M"].Value);
+			if (!monthProvided && !dayProvided)
+				return DateTime.MinValue;
+
+			int month = 0;
+			if (!monthProvided)
+				month = DateTime.Now.Month;
+			else {
+				month = Array.IndexOf (RegularExpressions.MonthsArray,
+				                       match.Groups ["M"].Value.ToLower ());
+				if (month == -1)
+					return DateTime.MinValue;
+				// Months start in 1.
+				month = (month / 2) + 1;
+			}
+
+			int day = -1;
+			if (dayProvided) {
+				if (!match.Groups ["O"].Value.ToOrdinalNumber (out day))
+					return DateTime.MinValue;
+			}
+			int year =  DateTime.Today.Year;
+			if (DateTime.Today.Month > month)
+				year++;
+
+			// If no day is provided, default is last one of the month
+			if (day == -1)
+				day = DateTime.DaysInMonth (year, month);
+
+			try {
+				return new DateTime (year, month, day);
+			} catch (Exception ex) {
+				if (ex is ArgumentOutOfRangeException
+				    || ex is ArgumentException) {
+					return DateTime.MinValue;
+				} else
+					throw;
+			}
+		}
+	}
+}
diff --git a/src/libtasque/DateFormatters/IDateFormatter.cs b/src/libtasque/DateFormatters/IDateFormatter.cs
new file mode 100644
index 0000000..4c48d78
--- /dev/null
+++ b/src/libtasque/DateFormatters/IDateFormatter.cs
@@ -0,0 +1,33 @@
+// Author:
+//       Mario Carrion <mario@carrion.mx>
+// 
+// Copyright (c) 2010 Mario Carrion
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+using System.Text.RegularExpressions;
+
+namespace Tasque.DateFormatters {
+
+	interface IDateFormatter {
+		DateTime GetDate (Match match);
+	}
+
+}
diff --git a/src/libtasque/DateFormatters/MonthFormatter.cs b/src/libtasque/DateFormatters/MonthFormatter.cs
new file mode 100644
index 0000000..765c849
--- /dev/null
+++ b/src/libtasque/DateFormatters/MonthFormatter.cs
@@ -0,0 +1,46 @@
+// Author:
+//       Mario Carrion <mario@carrion.mx>
+// 
+// Copyright (c) 2010 Mario Carrion
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+
+namespace Tasque.DateFormatters {
+
+	class MonthFormatter : QuantityFormatter {
+
+		public MonthFormatter ()
+			: base ("m")
+		{
+		}
+
+		public override DateTime GetDate (int quantity)
+		{
+			return DateTime.Now.AddMonths (quantity);
+		}
+
+		protected override string RegularExpression {
+			get { return RegularExpressions.Month; }
+		}
+
+	}
+
+}
diff --git a/src/libtasque/DateFormatters/OrdinalFormatter.cs b/src/libtasque/DateFormatters/OrdinalFormatter.cs
new file mode 100644
index 0000000..450b9ce
--- /dev/null
+++ b/src/libtasque/DateFormatters/OrdinalFormatter.cs
@@ -0,0 +1,57 @@
+// Author:
+//       Mario Carrion <mario@carrion.mx>
+// 
+// Copyright (c) 2010 Mario Carrion
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+using System.Text.RegularExpressions;
+
+namespace Tasque.DateFormatters {
+
+	class OrdinalFormatter : IDateFormatter {
+
+		public DateTime GetDate (Match match)
+		{
+			string ordinalDate = match.Groups ["O"].Value;
+			if (string.IsNullOrEmpty (ordinalDate))
+				return DateTime.MinValue;
+
+			// If no day is provided, default is 1st
+			int day = 0;
+			if (!ordinalDate.ToOrdinalNumber (out day))
+				return DateTime.MinValue;
+
+			try {
+				return new DateTime (DateTime.Now.Year,
+				                      DateTime.Now.Month,
+				                      day);
+			} catch (Exception ex) {
+				if (ex is ArgumentOutOfRangeException
+				    || ex is ArgumentException) {
+					return DateTime.MinValue;
+				} else
+					throw;
+			}
+		}
+
+
+	}
+}
diff --git a/src/libtasque/DateFormatters/QuantityFormatter.cs b/src/libtasque/DateFormatters/QuantityFormatter.cs
new file mode 100644
index 0000000..3bad06c
--- /dev/null
+++ b/src/libtasque/DateFormatters/QuantityFormatter.cs
@@ -0,0 +1,99 @@
+// Author:
+//       Mario Carrion <mario@carrion.mx>
+// 
+// Copyright (c) 2010 Mario Carrion
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+using System.Collections.Generic;
+using System.Text.RegularExpressions;
+using System.Linq;
+
+namespace Tasque.DateFormatters {
+
+	abstract class QuantityFormatter : IDateFormatter {
+
+		#region Constructor
+
+		protected QuantityFormatter (string token)
+		{
+			this.token = token;
+		}
+
+		#endregion
+
+		#region IDateFormatter
+
+		public DateTime GetDate (Match match)
+		{
+			if (string.IsNullOrEmpty (match.Groups [token].Value)
+			    || !Translations.Contains (match.Groups [token].Value,
+			                               new StringInsensitiveComparer ()))
+				return DateTime.MinValue;
+
+			return GetDate (GetCardinal (match));
+		}
+
+		#endregion
+		
+		#region Public Members
+
+		public abstract DateTime GetDate (int quantity);
+
+		#endregion
+		
+		#region Protected Members
+
+		protected List<string> Translations {
+			get {
+				if (translations == null)
+					translations = new List<string> (RegularExpression.Split ('|'));
+				return translations;
+			}
+		}
+
+		protected abstract string RegularExpression {
+			get;
+		}
+
+		protected int GetCardinal (Match match)
+		{
+			int cardinal = 1;
+			string cardinalStr = match.Groups ["N"].Value;
+			// We don't validate "correct literal value", 
+			// in English:
+			// "Something in months" or "Something in 3 month"
+			if (!string.IsNullOrEmpty (cardinalStr)) {
+				if (!int.TryParse (cardinalStr, out cardinal))
+					throw new ArgumentException ("cardinal");
+			}
+			return cardinal;
+		}
+
+		#endregion
+		
+		#region Private Members
+
+		List<string> translations;
+		string token;
+
+		#endregion
+	}
+}
diff --git a/src/libtasque/DateFormatters/StringInsensitiveComparer.cs b/src/libtasque/DateFormatters/StringInsensitiveComparer.cs
new file mode 100644
index 0000000..f519ec3
--- /dev/null
+++ b/src/libtasque/DateFormatters/StringInsensitiveComparer.cs
@@ -0,0 +1,40 @@
+// Author:
+//       Mario Carrion <mario@carrion.mx>
+// 
+// Copyright (c) 2010 Mario Carrion
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System.Collections.Generic;
+
+namespace Tasque.DateFormatters {
+
+	class StringInsensitiveComparer : IEqualityComparer<string>
+	{
+		public bool Equals (string str1, string str2)
+		{
+			return string.Compare (str1, str2, true) == 0;
+		}
+
+		public int GetHashCode (string str1)
+		{
+			return str1.GetHashCode ();
+		}
+	}
+}
diff --git a/src/libtasque/DateFormatters/TodayTomorrowFormatter.cs b/src/libtasque/DateFormatters/TodayTomorrowFormatter.cs
new file mode 100644
index 0000000..3072007
--- /dev/null
+++ b/src/libtasque/DateFormatters/TodayTomorrowFormatter.cs
@@ -0,0 +1,45 @@
+// Author:
+//       Mario Carrion <mario@carrion.mx>
+// 
+// Copyright (c) 2010 Mario Carrion
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+using System.Text.RegularExpressions;
+
+namespace Tasque.DateFormatters {
+
+	class TodayTomorrowFormatter : IDateFormatter {
+
+		public DateTime GetDate (Match match)
+		{
+			string t = match.Groups ["T"].Value;
+
+			if (string.Compare (t, RegularExpressions.Tomorrow, true) == 0)
+				return DateTime.Now.AddDays (1);
+			else if (string.Compare (t, RegularExpressions.Today, true) == 0)
+				return DateTime.Now;
+
+			return DateTime.MinValue;
+		}
+
+	}
+
+}
diff --git a/src/libtasque/DateFormatters/WeekFormatter.cs b/src/libtasque/DateFormatters/WeekFormatter.cs
new file mode 100644
index 0000000..c122846
--- /dev/null
+++ b/src/libtasque/DateFormatters/WeekFormatter.cs
@@ -0,0 +1,45 @@
+// Author:
+//       Mario Carrion <mario@carrion.mx>
+// 
+// Copyright (c) 2010 Mario Carrion
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+
+namespace Tasque.DateFormatters {
+
+	class WeekFormatter : QuantityFormatter {
+
+		public WeekFormatter ()
+			: base ("w")
+		{
+		}
+
+		public override DateTime GetDate (int quantity)
+		{
+			return DateTime.Now.AddDays (7 * quantity);
+		}
+
+		protected override string RegularExpression {
+			get { return RegularExpressions.Week; }
+		}
+
+	}
+}
diff --git a/src/libtasque/DateFormatters/WeekdayFormatter.cs b/src/libtasque/DateFormatters/WeekdayFormatter.cs
new file mode 100644
index 0000000..619366a
--- /dev/null
+++ b/src/libtasque/DateFormatters/WeekdayFormatter.cs
@@ -0,0 +1,50 @@
+// Author:
+//       Mario Carrion <mario@carrion.mx>
+// 
+// Copyright (c) 2010 Mario Carrion
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+using System.Text.RegularExpressions;
+
+namespace Tasque.DateFormatters {
+
+	// D
+	class WeekdayFormatter : IDateFormatter {
+
+		public DateTime GetDate (Match match)
+		{
+			string weekDay = match.Groups ["D"].Value;
+			if (string.IsNullOrEmpty (weekDay))
+				return DateTime.MinValue;
+
+			DateTime todayDateTime = DateTime.Now;
+			uint today = todayDateTime.DayOfWeek.ToUint ();
+			uint future = weekDay.ToDayOfWeek ().ToUint ();
+			if (future > today) 
+				return DateTime.Now.AddDays (future - today);
+			else if (today > future)
+				return DateTime.Now.AddDays (7 - (today - future));
+			else // future is in one week
+				return DateTime.Now.AddDays (7);
+		}
+
+	}
+}
diff --git a/src/libtasque/DateFormatters/YearFormatter.cs b/src/libtasque/DateFormatters/YearFormatter.cs
new file mode 100644
index 0000000..59fc653
--- /dev/null
+++ b/src/libtasque/DateFormatters/YearFormatter.cs
@@ -0,0 +1,45 @@
+// Author:
+//       Mario Carrion <mario@carrion.mx>
+// 
+// Copyright (c) 2010 Mario Carrion
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+
+namespace Tasque.DateFormatters {
+
+	class YearFormatter : QuantityFormatter {
+
+		public YearFormatter ()
+			: base ("y")
+		{
+		}
+
+		public override DateTime GetDate (int quantity)
+		{
+			return DateTime.Now.AddYears (quantity);
+		}
+
+		protected override string RegularExpression {
+			get { return RegularExpressions.Year; }
+		}
+
+	}
+}
diff --git a/src/libtasque/RegularExpressionAttribute.cs b/src/libtasque/RegularExpressionAttribute.cs
new file mode 100644
index 0000000..bee0150
--- /dev/null
+++ b/src/libtasque/RegularExpressionAttribute.cs
@@ -0,0 +1,38 @@
+// Author:
+//       Mario Carrion <mario@carrion.mx>
+// 
+// Copyright (c) 2010 Mario Carrion
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+using Tasque.DateFormatters;
+
+namespace Tasque {
+
+	// Used to decorate all Translatable Regular Expressions
+	[AttributeUsage (AttributeTargets.Field, AllowMultiple = false)]
+	class RegularExpressionAttribute : Attribute {
+
+		public RegularExpressionAttribute ()
+		{
+		}
+
+	}
+}
diff --git a/src/libtasque/RegularExpressionFormatter.cs b/src/libtasque/RegularExpressionFormatter.cs
new file mode 100644
index 0000000..5b01387
--- /dev/null
+++ b/src/libtasque/RegularExpressionFormatter.cs
@@ -0,0 +1,60 @@
+// Author:
+//       Mario Carrion <mario@carrion.mx>
+// 
+// Copyright (c) 2010 Mario Carrion
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+using System.Collections.Generic;
+using Tasque.DateFormatters;
+
+namespace Tasque {
+
+	// Used to keep a relation of Regular Expression and the
+	// formatters used to get the date.
+	class RegularExpressionFormatter {
+
+		public RegularExpressionFormatter ()
+		{
+		}
+
+		public string RegularExpression {
+			get { return regularExpression; }
+			set {
+				if (value == null)
+					throw new ArgumentNullException ("RegularExpression");
+				regularExpression = value;
+			}
+		}
+
+		public IEnumerable<IDateFormatter> Formatters {
+			get { return formatters; }
+			set {
+				if (value == null)
+					throw new ArgumentNullException ("Formatters");
+				formatters = value;
+			}
+		}
+
+		IEnumerable<IDateFormatter> formatters;
+		string regularExpression;
+	}
+
+}
diff --git a/src/libtasque/RegularExpressions.cs b/src/libtasque/RegularExpressions.cs
new file mode 100644
index 0000000..d1675af
--- /dev/null
+++ b/src/libtasque/RegularExpressions.cs
@@ -0,0 +1,346 @@
+// Author:
+//       Mario Carrion <mario@carrion.mx>
+// 
+// Copyright (c) 2010 Mario Carrion
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using Mono.Unix;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Text.RegularExpressions;
+using Tasque.DateFormatters;
+
+namespace Tasque {
+
+	public static class RegularExpressions {
+
+		#region Tokens
+
+		// L10N: Read TRANSLATORS file for a detailed information about this string
+		public static readonly string OrdinalNumbers = Catalog.GetString ("11|12|13=th,1=st,2=nd,3=rd,default=th");
+
+		public static readonly string OrdinalSuffixes = GenerateOrdinalSuffixes ();
+
+		public static readonly string Today = Catalog.GetString ("today");
+
+		public static readonly string Tomorrow = Catalog.GetString ("tomorrow");
+
+		[Token ('M', Formatter = typeof (DateFormatter))]
+		public static readonly string Months = string.Join ("|", MonthsArray);
+
+		[Token ('D', Formatter = typeof (WeekdayFormatter))]
+		public static readonly string Weekdays = string.Join ("|", WeekdaysArray);
+
+		[Token ('T', Formatter = typeof (TodayTomorrowFormatter))]
+		public static readonly string TodayTomorrow = string.Format ("{0}|{1}", Today, Tomorrow);
+
+		[Token ('O', Formatter = typeof (DateFormatter))]
+		public static readonly string OrdinalNumber = string.Format ("{0}({1})?",
+		                                                                  @"\d{1,2}",
+		                                                                  OrdinalSuffixes);
+
+		[Token ('N')]
+		public static readonly string CardinalNumber = string.Format ("{0}", @"[1-9][0-9]?");
+
+		[Token ('u')]
+		public static readonly string Due = Catalog.GetString ("due before|due by|due");
+
+		[Token ('w', Formatter = typeof (WeekFormatter))]
+		// L10N: Don't forget to include plurar value, if any
+		public static readonly string Week = Catalog.GetString ("week|weeks");
+
+		[Token ('m', Formatter = typeof (MonthFormatter))]
+		// L10N: Don't forget to include plurar value, if any
+		public static readonly string Month = Catalog.GetString ("month|months");
+
+		[Token ('y', Formatter = typeof (YearFormatter))]
+		// L10N: Don't forget to include plurar value, if any
+		public static readonly string Year = Catalog.GetString ("year|years");
+
+		[Token ('n')]
+		// L10N: Examples could be: "Next Month", "Next Monday"
+		public static readonly string Next = Catalog.GetString ("next");
+
+		[Token ('o')]
+		// L10N: Examples could be: "On April 1st", "On Wednesday"
+		public static readonly string On = Catalog.GetString ("on");
+
+		[Token ('i')]
+		// L10N: Examples could be: "In 2 weeks", "In 3 months"
+		public static readonly string In = Catalog.GetString ("in");
+
+		#endregion
+
+		#region Regular Expressions
+
+		[RegularExpression]
+		// RegEx: Read TRANSLATORS file for a detailed information about this string
+		public static readonly string TodayTorromowExpression = Catalog.GetString (@"u T|T");
+
+		[RegularExpression]
+		// RegEx: Read TRANSLATORS file for a detailed information about this string
+		public static readonly string NextExpression = Catalog.GetString ("n w|n m|n y|n D");
+
+		[RegularExpression]
+		// RegEx: Read TRANSLATORS file for a detailed information about this string
+		public static readonly string DueExpression = Catalog.GetString (@"u o D|u O|u M O|u M");
+
+		[RegularExpression]
+		// RegEx: Read TRANSLATORS file for a detailed information about this string
+		public static readonly string OnExpression = Catalog.GetString (@"o D|o O");
+
+		[RegularExpression]
+		// RegEx: Read TRANSLATORS file for a detailed information about this string
+		public static readonly string InExpression = Catalog.GetString (@"i N w|i w|i N m|i m|i N y|i y");
+
+		#endregion
+
+		#region Extension methods
+
+		internal static uint ToUint (this DayOfWeek dayOfWeek)
+		{
+			switch (dayOfWeek) {
+			case DayOfWeek.Sunday:
+				return 0;
+			case DayOfWeek.Monday:
+				return 1;
+			case DayOfWeek.Tuesday:
+				return 2;
+			case DayOfWeek.Wednesday:
+				return 3;
+			case DayOfWeek.Thursday:
+				return 4;
+			case DayOfWeek.Friday:
+				return 5;
+			case DayOfWeek.Saturday:
+			default:
+				return 6;
+			}
+		}
+
+		internal static DayOfWeek ToDayOfWeek (this string str)
+		{
+			str = str.ToLower ();
+			int indexOf
+				= Array.IndexOf (RegularExpressions.WeekdaysArray, str);
+			if (indexOf == -1)
+				throw new ArgumentException (string.Format ("Wrong day {0}",
+				                                             str));
+
+			switch (indexOf) {
+			case 0:
+			case 1:
+				return DayOfWeek.Sunday;
+			case 2:
+			case 3:
+				return DayOfWeek.Monday;
+			case 4:
+			case 5:
+				return DayOfWeek.Tuesday;
+			case 6:
+			case 7:
+				return DayOfWeek.Wednesday;
+			case 8:
+			case 9:
+				return DayOfWeek.Thursday;
+			case 10:
+			case 11:
+				return DayOfWeek.Friday;
+			case 12:
+			case 13:
+			default:
+				return DayOfWeek.Saturday;
+			}
+		}
+
+		internal static bool IsMonth (this string str)
+		{
+			return RegularExpressions.MonthsArray.Contains (str.ToLower ());
+		}
+
+		internal static bool IsWeekday (this string str)
+		{
+			return RegularExpressions.WeekdaysArray.Contains (str.ToLower ());
+		}
+
+		internal static bool IsValidOrdinalNumber (this string str,
+		                                             out int day)
+		{
+			day = 0;
+
+			int cardinal = 0;
+			string sufix = string.Empty;
+			str = str.ToLower ();
+
+			if (str.Length < 3)
+				return int.TryParse (str, out day);
+			else if (str.Length == 3) { // something like 1st
+				if (!int.TryParse (str.Substring (0, 1), out cardinal))
+					return false;
+				sufix = str.Substring (1);
+			} else { // something like 11th,
+				if (!int.TryParse (str.Substring (0, 2), out cardinal))
+					return false;
+				sufix = str.Substring (2);
+			}
+
+			string expectedSufix = string.Empty;
+			if (!SuffixesDictionary.TryGetValue (cardinal,
+			                                     out expectedSufix)) {
+				// It was not found and the last digit is still valid,
+				// ie, 22nd, should use 2nd
+				if (cardinal > 9) {
+					// 22nd
+					int c = 0;
+					if (!int.TryParse (str.Substring (1, 1), out c))
+						return false;
+					// and if that is still failing, then use default sufix
+					if (!SuffixesDictionary.TryGetValue (c,
+					                                     out expectedSufix))
+						expectedSufix = DefaultSuffix;
+				} else
+					expectedSufix = DefaultSuffix;
+			}
+
+			if (expectedSufix != sufix)
+				return false;
+
+			day = cardinal;
+			return true;
+		}
+
+		internal static bool ToOrdinalNumber (this string ordinalDate,
+		                                        out int day)
+		{
+			day = -1;
+
+			if (string.IsNullOrEmpty (ordinalDate))
+				return false;
+
+			// It could be 11 or 1st, we need to make sure
+			// is valid ordinal based on the locale.
+			if (ordinalDate.Length > 2) {
+				if (!ordinalDate.IsValidOrdinalNumber (out day))
+					return false;
+			} else {
+				if (!int.TryParse (ordinalDate, out day))
+					return false;
+			}
+
+			return true;
+		}
+
+		#endregion
+
+		#region Private Members
+
+		internal static string[] WeekdaysArray {
+			get {
+				if (weekdays == null) {
+					List<string> list  = new List<string> (7);
+					// To begin on Sunday January 7th 1900.
+					// Sunday is our index 0
+					foreach (int day in Enumerable.Range (7, 7)) {
+						DateTime date = new DateTime (1900, 1, day);
+						list.Add (date.ToString ("dddd").ToLower ());
+						list.Add (date.ToString ("ddd").ToLower ());
+					}
+					weekdays = list.ToArray ();
+				}
+				return weekdays;
+			}
+		}
+		static string[] weekdays;
+
+		internal static string[] MonthsArray {
+			get {
+				if (months == null) {
+					List<string> list  = new List<string> (12);
+					foreach (int month in Enumerable.Range (1, 12)) {
+						DateTime date = new DateTime (1900, month, 1);
+						list.Add (date.ToString ("MMMM").ToLower ());
+						list.Add (date.ToString ("MMM").ToLower ());
+					}
+					months = list.ToArray ();
+				}
+				return months;
+			}
+		}
+		static string[] months;
+
+		// Based on the translated string we generate the suffixes string.
+		static string GenerateOrdinalSuffixes ()
+		{
+			List<string> suffixes = new List<string> ();
+
+			foreach (KeyValuePair<int, string> valuePair
+			         in SuffixesDictionary) {
+				if (!suffixes.Contains (valuePair.Value))
+					suffixes.Add (valuePair.Value);
+			}
+
+			return string.Join ("|", suffixes.ToArray ());
+		}
+
+		internal static string DefaultSuffix { get; set; }
+
+		internal static Dictionary<int,string> SuffixesDictionary {
+			get {
+				if (suffixesDictionary == null) {
+					// Matches: "11|12|13"
+					string alternatives = @"((\d{1,2})+(\|\d{1,2})*)";
+					// Matches: "11""12""13", used when "11|12|13=th,2=nd"
+					string days = @"\b((\d{1,2})+((?<=\|)\d{1,2})*)\b";
+					// Matches "dayOrDays=suffix"
+					string expression
+						= string.Format (@"\b(?<days>({0}|\w+))=(?<suffix>\w+)\b", alternatives);
+					suffixesDictionary = new Dictionary<int, string> ();
+					Regex regex = new Regex (expression,
+					                         RegexOptions.IgnoreCase);
+					foreach (Match match 
+					         in regex.Matches (RegularExpressions.OrdinalNumbers)) {
+						if (match.Groups ["days"].Value == "default") {
+							DefaultSuffix = match.Groups ["suffix"].Value.ToLower ();
+							continue;
+						}
+
+						// Matching: 11=th, 12=th, 13=th
+						Regex regexDays = new Regex (days, RegexOptions.IgnoreCase);
+						foreach (Match matchDay
+							      in regexDays.Matches (match.Groups ["days"].Value)) {
+							// We want to crash if two numbers are added.
+							suffixesDictionary.Add (Convert.ToInt32 (matchDay.Value),
+							                        match.Groups ["suffix"].Value.ToLower ());
+						}
+					}
+					if (DefaultSuffix == null)
+						throw new ArgumentNullException ("No default ordinal prefix provided");
+				}
+				return suffixesDictionary;
+			}
+		}
+		static Dictionary<int,string> suffixesDictionary;
+
+		#endregion
+
+	}
+}
diff --git a/src/libtasque/TaskParser.cs b/src/libtasque/TaskParser.cs
new file mode 100644
index 0000000..749288e
--- /dev/null
+++ b/src/libtasque/TaskParser.cs
@@ -0,0 +1,262 @@
+// Author:
+//       Mario Carrion <mario@carrion.mx>
+// 
+// Copyright (c) 2010 Mario Carrion
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Reflection;
+using System.Text;
+using System.Text.RegularExpressions;
+
+using Tasque.DateFormatters;
+
+namespace Tasque {
+	
+	// TODO: Support for time parsing
+
+	public class TaskParser {
+		
+		#region Static Members
+		
+		public static TaskParser Instance {
+			get {
+				if (instance == null)
+					instance = new TaskParser ();
+				return instance;
+			}
+		}
+		static TaskParser instance;
+
+		// Matches anything like this: "a b cd|e f g 'xy'"
+		static readonly string AlternativesExpression = @"(\w|\s|\'|\\)+((?<=\|)(\w|\s|\'|\\)+)*";
+
+		// Matches format and explicit '' delimited text
+		static readonly string TokensExpression = @"(\b\w\b|'\w+')+((?<=\s)(\b\w\b|'\w+'))*";
+
+		// Expression that defines the named group "<?date>"
+		static readonly string DateGroupExpression  = @"(?>\\)(\b\w\b|'\w+')+(?>.*?\\)";
+
+		#endregion
+		
+		TaskParser ()
+		{
+			fullExpression = string.Format ("{0}|{1}",
+			                                TokensExpression,
+			                                DateGroupExpression);
+
+			// 1. Get all translatable token
+			FillTranslatableTokens ();
+
+			// 2. Get all regular expressions, these are also translatable
+			//    and are based on the translatable tokens.
+			regExFormats = GetRegularExpressions ();
+		}
+
+		public bool TryParse (string enteredTaskText,
+		                        out string parsedTaskText,
+		                        out DateTime dueDateTime)
+		{
+			dueDateTime = DateTime.MinValue;
+			parsedTaskText = enteredTaskText;
+
+			foreach (RegularExpressionFormatter format in regExFormats) {
+				string regEx = string.Format (@"^(?<task>.+?)\s*?{0}(?<eol>.*)$",
+				                               format.RegularExpression);
+				Match match = Regex.Match (enteredTaskText,
+				                           regEx,
+				                           RegexOptions.IgnoreCase);
+				if (match.Success) {
+					string trimmedTaskText = match.Groups ["task"].Value;
+					if (!string.IsNullOrEmpty (trimmedTaskText)) {
+						foreach (IDateFormatter formatter in format.Formatters) {
+							dueDateTime = formatter.GetDate (match);
+							if (dueDateTime != DateTime.MinValue)
+								break;
+						}
+						if (dueDateTime == DateTime.MinValue)
+							return false;
+
+						string trimmedEofText = match.Groups ["eol"].Value;
+						parsedTaskText = string.Format ("{0}{1}", trimmedTaskText, trimmedEofText);
+						return true;
+					}
+				}
+			}
+			return false;
+		}
+
+		#region Private Members
+
+		// Based on the Fields decorated with "RegularTokenAttribute" in
+		// "RegularExpressions" class we create a Dictionary to keep a 
+		// dictionary: Key="RegularTokenAttribute.Token"/Value="FieldDecorated".
+		void FillTranslatableTokens ()
+		{
+			translatableTokens = new Dictionary<char, TranslatableToken> ();
+
+			FieldInfo[] fields
+				= typeof (RegularExpressions).GetFields (BindingFlags.Static
+				                                         | BindingFlags.Public);
+			foreach (FieldInfo field in fields) {
+				object[] attributes = field.GetCustomAttributes (false);
+				if (attributes.Length == 0)
+					continue;
+
+				// We know our attribute is not AllowMultiple, so there's
+				// always one.
+				TokenAttribute tokenAttribute
+					= attributes [0] as TokenAttribute;
+				if (tokenAttribute == null)
+					continue;
+
+				string expression = field.GetValue (null) as string;
+				if (expression == null)
+					throw new ArgumentException (string.Format ("Field is not string: '{0}'",
+					                                             field.Name));
+
+				// We DON'T want to use [], we want to crash if something
+				// is duplicated.
+				translatableTokens.Add (tokenAttribute.Token,
+				                        new TranslatableToken () {
+				                             Token = tokenAttribute.Token,
+				                             Formatter = tokenAttribute.Formatter,
+				                             Expression = expression.Replace (" ", @"\s+"),
+				                        });
+			}
+		}
+
+		string GenerateRegularExpression (string translatedExpression)
+		{
+			List<string> expressionList = new List<string> ();
+			Regex regex = new Regex (fullExpression, RegexOptions.IgnoreCase);
+			foreach (Match match in regex.Matches (translatedExpression)) {
+				// We found a match for a string like this: "\Something\"
+				if (Regex.IsMatch (match.Value, DateGroupExpression)) {
+					Regex dateRegEx = new Regex (TokensExpression, RegexOptions.IgnoreCase);
+					string date = "(?<date>";
+					List<string> dateList = new List<string> ();
+					foreach (Match token in dateRegEx.Matches (match.Value))
+						dateList.Add (GetFormatedToken (token));
+					date += string.Join (@"\s+", dateList.ToArray ()) + ")";
+					expressionList.Add (date);
+				// Using translated tokens
+				} else
+					expressionList.Add (GetFormatedToken (match));
+			}
+			return String.Join (@"\s+", expressionList.ToArray ());
+		}
+
+		string GetFormatedToken (Match match)
+		{
+			// It's a translatable token, we need it named.
+			if (match.Value.Length == 1) {
+				char token = match.Value [0];
+				string savedTokens = translatableTokens [token].Expression;
+				return string.Format (@"(?<{0}>\b({1})\b)", token, savedTokens);
+			// It's a "hardcoded" translated string. We need the complete word
+			} else
+				return string.Format (@"({0})", match.Value.Replace ("'", @"\b"));
+		}
+		
+		List<IDateFormatter> GetFormatters (string expression)
+		{
+			List<IDateFormatter> formatters = new List<IDateFormatter> ();
+			foreach (string str in expression.Split (' ')) {
+				char token = char.MinValue;
+				if (!char.TryParse (str, out token))
+					continue;
+
+				TranslatableToken translatableToken = null;
+				if (!translatableTokens.TryGetValue (token,
+				                                     out translatableToken))
+					continue;
+
+				if (translatableToken.Formatter == null)
+					continue;
+
+				IDateFormatter formatter = DateFormatterFactory
+					.Instance.Get (translatableToken.Formatter);
+				if (!formatters.Contains (formatter))
+					formatters.Add (formatter);
+			}
+			if (formatters.Count == 0)
+				throw new Exception ("No formatters");
+
+			return formatters;
+		}
+
+		// Read "RegularExpressions" class and get all fields decorated
+		// with "RegularExpressionAttribute". All these fields represent
+		// the expressions to match.
+		List<RegularExpressionFormatter> GetRegularExpressions ()
+		{
+			List<RegularExpressionFormatter> regularExpressions
+				= new List<RegularExpressionFormatter> ();
+			FieldInfo[] fields
+				= typeof (RegularExpressions).GetFields (BindingFlags.Static
+				                                         | BindingFlags.Public);
+			foreach (FieldInfo field in fields) {
+				object[] attributes = field.GetCustomAttributes (false);
+				if (attributes.Length == 0)
+					continue;
+
+				// Is not AllowMultiple
+				RegularExpressionAttribute regAttribute
+						= attributes [0] as RegularExpressionAttribute;
+				if (regAttribute == null)
+					continue;
+
+				string expression = field.GetValue (null) as string;
+				if (expression == null)
+					throw new ArgumentException (string.Format ("Field is not string: '{0}'",
+					                                             field.Name));
+
+				foreach (string alternativeExpression 
+				         in GetAlternativesExpressions (expression)) {
+					regularExpressions.Add (new RegularExpressionFormatter () {
+					                           RegularExpression = GenerateRegularExpression (alternativeExpression),
+					                           Formatters = GetFormatters (alternativeExpression)
+					                        });
+				}
+			}
+			return regularExpressions;
+		}
+
+		// Spliting all "|" separated expressions (RegularExpressions)
+		List<string> GetAlternativesExpressions (string expression)
+		{
+			List<string> expressionList = new List<string> ();
+			Regex regex = new Regex (AlternativesExpression, 
+			                         RegexOptions.IgnoreCase);
+			foreach (Match match in regex.Matches (expression))
+				expressionList.Add (match.Value);
+			return expressionList;
+		}
+
+		string fullExpression;
+		List<RegularExpressionFormatter> regExFormats;
+		Dictionary<char, TranslatableToken> translatableTokens;
+
+		#endregion
+	}
+}
diff --git a/src/libtasque/TokenAttribute.cs b/src/libtasque/TokenAttribute.cs
new file mode 100644
index 0000000..15f1362
--- /dev/null
+++ b/src/libtasque/TokenAttribute.cs
@@ -0,0 +1,50 @@
+// Author:
+//       Mario Carrion <mario@carrion.mx>
+// 
+// Copyright (c) 2010 Mario Carrion
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+
+namespace Tasque {
+
+	// Used to define the token used in the translatable regular expression
+	[AttributeUsage (AttributeTargets.Field, AllowMultiple = false)]
+	class TokenAttribute : Attribute {
+
+		public TokenAttribute (char token)
+		{
+			if (token == null)
+				throw new NullReferenceException ("token");
+
+			Token = token;
+		}
+
+		public char Token {
+			get;
+			private set;
+		}
+
+		public Type Formatter {
+			get;
+			set;
+		}
+	}
+}
diff --git a/src/libtasque/TranslatableToken.cs b/src/libtasque/TranslatableToken.cs
new file mode 100644
index 0000000..fe4353d
--- /dev/null
+++ b/src/libtasque/TranslatableToken.cs
@@ -0,0 +1,46 @@
+// Author:
+//       Mario Carrion <mario@carrion.mx>
+// 
+// Copyright (c) 2010 Mario Carrion
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+
+namespace Tasque {
+
+	class TranslatableToken {
+
+		public char Token {
+			get;
+			set;
+		}
+
+		public Type Formatter {
+			get;
+			set;
+		}
+
+		public string Expression {
+			get;
+			set;
+		}
+
+	}
+}
diff --git a/src/libtasque/libtasque.csproj b/src/libtasque/libtasque.csproj
index 3eb06e4..3a8cbcc 100644
--- a/src/libtasque/libtasque.csproj
+++ b/src/libtasque/libtasque.csproj
@@ -7,9 +7,9 @@
     <SchemaVersion>2.0</SchemaVersion>
     <ProjectGuid>{784C9AA8-2B28-400B-8CC4-DCDC48CA37F0}</ProjectGuid>
     <OutputType>Library</OutputType>
-    <RootNamespace>libtasque</RootNamespace>
+    <RootNamespace>Tasque</RootNamespace>
     <AssemblyName>libtasque</AssemblyName>
-    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -35,9 +35,44 @@
     <Compile Include="ITask.cs" />
     <Compile Include="TaskPriority.cs" />
     <Compile Include="TaskState.cs" />
+    <Compile Include="TaskParser.cs" />
+    <Compile Include="RegularExpressions.cs" />
+    <Compile Include="RegularExpressionAttribute.cs" />
+    <Compile Include="DateFormatterFactory.cs" />
+    <Compile Include="DateFormatters\IDateFormatter.cs" />
+    <Compile Include="DateFormatters\WeekdayFormatter.cs" />
+    <Compile Include="DateFormatters\OrdinalFormatter.cs" />
+    <Compile Include="DateFormatters\WeekFormatter.cs" />
+    <Compile Include="DateFormatters\StringInsensitiveComparer.cs" />
+    <Compile Include="DateFormatters\QuantityFormatter.cs" />
+    <Compile Include="DateFormatters\YearFormatter.cs" />
+    <Compile Include="DateFormatters\DateFormatter.cs" />
+    <Compile Include="TokenAttribute.cs" />
+    <Compile Include="DateFormatters\MonthFormatter.cs" />
+    <Compile Include="DateFormatters\TodayTomorrowFormatter.cs" />
+    <Compile Include="RegularExpressionFormatter.cs" />
+    <Compile Include="TranslatableToken.cs" />
   </ItemGroup>
   <ItemGroup>
     <Reference Include="gtk-sharp, Version=2.12.0.0, Culture=neutral, PublicKeyToken=35e10195dab3c99f" />
     <Reference Include="System" />
+    <Reference Include="System.Core" />
+    <Reference Include="Mono.Posix, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756">
+      <SpecificVersion>False</SpecificVersion>
+      <HintPath>..\..\winbin\Mono.Posix.dll</HintPath>
+    </Reference>
   </ItemGroup>
+  <ItemGroup>
+    <Folder Include="DateFormatters\" />
+  </ItemGroup>
+  <ProjectExtensions>
+    <MonoDevelop>
+      <Properties>
+        <Policies>
+          <DotNetNamingPolicy DirectoryNamespaceAssociation="PrefixedHierarchical" ResourceNamePolicy="MSBuild" />
+          <StandardHeader Text="Author:&#xA;      ${AuthorName} &lt;${AuthorEmail}&gt;&#xA;&#xA;Copyright (c) ${Year} ${CopyrightHolder}&#xA;&#xA;Permission is hereby granted, free of charge, to any person obtaining a copy&#xA;of this software and associated documentation files (the &quot;Software&quot;), to deal&#xA;in the Software without restriction, including without limitation the rights&#xA;to use, copy, modify, merge, publish, distribute, sublicense, and/or sell&#xA;copies of the Software, and to permit persons to whom the Software is&#xA;furnished to do so, subject to the following conditions:&#xA;&#xA;The above copyright notice and this permission notice shall be included in&#xA;all copies or substantial portions of the Software.&#xA;&#xA;THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR&#xA;IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,&#xA;FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE&#xA;AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER&#xA;LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,&#xA;OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN&#xA;THE SOFTWARE." inheritsSet="MITX11License" />
+        </Policies>
+      </Properties>
+    </MonoDevelop>
+  </ProjectExtensions>
 </Project>
\ No newline at end of file
diff --git a/tasque.csproj b/tasque.csproj
index d71b608..a945f72 100644
--- a/tasque.csproj
+++ b/tasque.csproj
@@ -9,7 +9,7 @@
     <OutputType>WinExe</OutputType>
     <NoStandardLibraries>false</NoStandardLibraries>
     <AssemblyName>tasque</AssemblyName>
-    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
     <FileAlignment>512</FileAlignment>
     <NoWin32Manifest>True</NoWin32Manifest>
     <RootNamespace>tasque</RootNamespace>
@@ -48,6 +48,7 @@
     <Reference Include="glib-sharp, Version=2.12.0.0, Culture=neutral, PublicKeyToken=35e10195dab3c99f" />
     <Reference Include="gtk-sharp, Version=2.12.0.0, Culture=neutral, PublicKeyToken=35e10195dab3c99f" />
     <Reference Include="pango-sharp, Version=2.12.0.0, Culture=neutral, PublicKeyToken=35e10195dab3c99f" />
+    <Reference Include="NDesk.DBus, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f6716e4f9b2ed099" />
   </ItemGroup>
   <ItemGroup>
     <None Include="ChangeLog" />
diff --git a/tasque.sln b/tasque.sln
index 4e9c7c6..10413d0 100644
--- a/tasque.sln
+++ b/tasque.sln
@@ -7,6 +7,8 @@ Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "RtmNet", "RtmNet\RtmNet.csp
 EndProject
 Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "libtasque", "src\libtasque\libtasque.csproj", "{784C9AA8-2B28-400B-8CC4-DCDC48CA37F0}"
 EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "tests", "tests\tests.csproj", "{6DC908EC-E7C2-46CD-A21D-832C0D81D946}"
+EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
 		Debug|Any CPU = Debug|Any CPU
@@ -17,6 +19,10 @@ Global
 		{0AA1B96E-03DE-4D26-B4FD-507E988FD9B7}.Debug|Any CPU.Build.0 = Debug|Any CPU
 		{0AA1B96E-03DE-4D26-B4FD-507E988FD9B7}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{0AA1B96E-03DE-4D26-B4FD-507E988FD9B7}.Release|Any CPU.Build.0 = Release|Any CPU
+		{6DC908EC-E7C2-46CD-A21D-832C0D81D946}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{6DC908EC-E7C2-46CD-A21D-832C0D81D946}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{6DC908EC-E7C2-46CD-A21D-832C0D81D946}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{6DC908EC-E7C2-46CD-A21D-832C0D81D946}.Release|Any CPU.Build.0 = Release|Any CPU
 		{784C9AA8-2B28-400B-8CC4-DCDC48CA37F0}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{784C9AA8-2B28-400B-8CC4-DCDC48CA37F0}.Debug|Any CPU.Build.0 = Debug|Any CPU
 		{784C9AA8-2B28-400B-8CC4-DCDC48CA37F0}.Release|Any CPU.ActiveCfg = Release|Any CPU
diff --git a/tests/DateGuesserTest.cs b/tests/DateGuesserTest.cs
new file mode 100644
index 0000000..5bd2759
--- /dev/null
+++ b/tests/DateGuesserTest.cs
@@ -0,0 +1,365 @@
+//
+// Author:
+//      Mario Carrion <mario@carrion.mx>
+//
+// Copyright (c) 2010 Mario Carrion
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+using NUnit.Framework;
+
+using Tasque;
+
+namespace Tasque.Tests {
+
+	[TestFixture]
+	public class DateGuesserTest {
+		
+		#region TomorrowTodayGuesser
+
+		[Test]
+		public void Today ()
+		{
+			DateGuesser guesser = DateGuesser.Instance;
+			
+			DateTime dateTime = DateTime.MinValue;
+			DateTime expected = DateTime.Today;
+			string task = string.Empty;
+			string text = string.Empty;
+
+			// #1
+			text = string.Format ("Sell something, {0}, on the internet", 
+			                       Constants.Today);
+			bool parsed = guesser.Parse (text, out task, out dateTime);
+			Assert.IsTrue (parsed, "#0");
+			Assert.AreEqual ("Sell something,, on the internet", task, "#1");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#2");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#3");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#4");
+			parsed = false;
+			dateTime = DateTime.MinValue;
+
+			// #2
+			text = string.Format ("Buy beer {0}", Constants.Today);
+			parsed = guesser.Parse (text, out task, out dateTime);
+			Assert.IsTrue (parsed, "#5");
+			Assert.AreEqual ("Buy beer", task, "#6");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#7");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#8");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#9");
+			parsed = false;
+			dateTime = DateTime.MinValue;
+			
+			// Due is separated by "|"
+			string[] dues = Constants.Due.Split (new string[] { "|" }, 
+			                                     StringSplitOptions.RemoveEmptyEntries);
+			foreach (string due in dues) {
+				if (string.IsNullOrEmpty (due))
+					continue;
+
+				// #3
+				text = string.Format ("Print tickets {0} {1}", due, Constants.Today);
+				parsed = guesser.Parse (text, out task, out dateTime);
+				Assert.IsTrue (parsed, "#10");
+				Assert.AreEqual ("Print tickets", 
+				                 task, 
+				                 string.Format ("#11 -> {0}", due));
+				Assert.AreEqual (expected.Month,
+				                 dateTime.Month, 
+				                 string.Format ("#12 -> {0}", due));
+				Assert.AreEqual (expected.Day, 
+				                 dateTime.Day, 
+				                 string.Format ("#13 -> {0}", due));
+				Assert.AreEqual (expected.Year, 
+				                 dateTime.Year, 
+				                 string.Format ("#14 -> {0}", due));
+				parsed = false;
+				dateTime = DateTime.MinValue;
+			}
+		}
+		
+		[Test]
+		public void Tomorrow ()
+		{
+			DateGuesser guesser = DateGuesser.Instance;
+			
+			DateTime dateTime = DateTime.MinValue;
+			DateTime expected = DateTime.Today.AddDays (1);
+			string task = string.Empty;
+			string text = string.Empty;
+
+			// #1
+			text = string.Format ("Sell something, {0}, on the internet", 
+			                       Constants.Tomorrow);
+			bool parsed = guesser.Parse (text, out task, out dateTime);
+			Assert.IsTrue (parsed, "#0");
+			Assert.AreEqual ("Sell something,, on the internet", task, "#1");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#2");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#3");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#4");
+			parsed = false;
+			dateTime = DateTime.MinValue;
+
+			// #2
+			text = string.Format ("Buy beer {0}", Constants.Tomorrow);
+			parsed = guesser.Parse (text, out task, out dateTime);
+			Assert.IsTrue (parsed, "#5");
+			Assert.AreEqual ("Buy beer", task, "#6");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#7");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#8");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#9");
+			parsed = false;
+			dateTime = DateTime.MinValue;
+			
+			// Due is separated by "|"
+			string[] dues = Constants.Due.Split (new string[] { "|" }, 
+			                                     StringSplitOptions.RemoveEmptyEntries);
+			foreach (string due in dues) {
+				if (string.IsNullOrEmpty (due))
+					continue;
+
+				// #3
+				text = string.Format ("Print tickets {0} {1}", due, Constants.Tomorrow);
+				parsed = guesser.Parse (text, out task, out dateTime);
+				Assert.IsTrue (parsed, "#10");
+				Assert.AreEqual ("Print tickets", 
+				                 task, 
+				                 string.Format ("#11 -> {0}", due));
+				Assert.AreEqual (expected.Month,
+				                 dateTime.Month, 
+				                 string.Format ("#12 -> {0}", due));
+				Assert.AreEqual (expected.Day, 
+				                 dateTime.Day, 
+				                 string.Format ("#13 -> {0}", due));
+				Assert.AreEqual (expected.Year, 
+				                 dateTime.Year, 
+				                 string.Format ("#14 -> {0}", due));
+				parsed = false;
+				dateTime = DateTime.MinValue;
+			}
+		}
+
+		#endregion
+
+		#region NextGuesser
+		
+		[Test]
+		public void NextMonth ()
+		{
+			DateTime dateTime = DateTime.MinValue;
+			string task = string.Empty;
+
+			DateTime expected = DateTime.Today.AddMonths (1);
+			string text = string.Format ("Sell something, {0} {1}, on the internet", 
+			                              Constants.Next, 
+			                              Constants.Month);
+			Assert.IsTrue (DateGuesser.Instance.Parse (text, out task, out dateTime), "#0");
+			Assert.AreEqual ("Sell something,, on the internet", task, "#1");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#2");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#3");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#4");
+		}
+
+		[Test]
+		public void NextWeek ()
+		{
+			DateTime dateTime = DateTime.MinValue;
+			string task = string.Empty;
+			DateTime expected = DateTime.Today.AddDays (7);
+
+			string text = string.Format ("Buy beer {0} {1}",
+			                              Constants.Next,
+			                              Constants.Week);
+			Assert.IsTrue (DateGuesser.Instance.Parse (text, out task, out dateTime), "#1");
+			Assert.AreEqual ("Buy beer", task, "#2");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#3");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#4");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#5");
+		}
+		
+		[Test]
+		public void NextYear ()
+		{
+			DateTime dateTime = DateTime.MinValue;
+			string task = string.Empty;
+
+			DateTime expected = DateTime.Today.AddYears (1);
+			string text = string.Format ("Buy a house {0} {1}",
+			                              Constants.Next,
+			                              Constants.Year);
+			Assert.IsTrue (DateGuesser.Instance.Parse (text, out task, out dateTime), "#1");
+			Assert.AreEqual ("Buy a house", task, "#2");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#3");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#4");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#5");
+		}
+
+		[Test]
+		public void NextMonday ()
+		{
+			DateTime dateTime = DateTime.MinValue;
+			string task = string.Empty;
+
+			DateTime expected = DateTime.Today.AddDays (GetDayOffset (DayOfWeek.Monday));
+			string text = string.Format ("Doctor appointment {0} {1}", 
+			                             Constants.Next, 
+			                             Utilities.GetLocalizedDayOfWeek (DayOfWeek.Monday));
+			Assert.IsTrue (DateGuesser.Instance.Parse (text, out task, out dateTime), "#0");
+			Assert.AreEqual ("Doctor appointment", task, "#1");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#2");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#3");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#4");
+		}
+
+		[Test]
+		public void OnNextMonday ()
+		{
+			DateTime dateTime = DateTime.MinValue;
+			string task = string.Empty;
+
+			DateTime expected = DateTime.Today.AddDays (GetDayOffset (DayOfWeek.Monday));
+			string text = string.Format ("Doctor appointment {0} {1} {2}",
+			                             Constants.On,
+			                             Constants.Next,
+			                             Utilities.GetLocalizedDayOfWeek (DayOfWeek.Monday));
+			Assert.IsTrue (DateGuesser.Instance.Parse (text, out task, out dateTime), "#0");
+			Assert.AreEqual ("Doctor appointment", task, "#1");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#2");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#3");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#4");
+		}
+
+		#endregion
+		
+		#region DueGuesser 
+		
+		[Test]
+		public void DueValid ()
+		{
+			DateGuesser guesser = DateGuesser.Instance;
+			
+			DateTime dateTime = DateTime.MinValue;
+			DateTime expected = DateTime.MinValue;
+			string task = string.Empty;
+
+			// January
+			string text = string.Format ("Sell something due {0} 12", Constants.Months [0]);
+			expected = GetMonthDate (1, 12);
+
+			Assert.IsTrue (guesser.Parse (text, out task, out dateTime), "#0");
+			Assert.AreEqual ("Sell something", task, "#1");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#2");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#3");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#4");
+			dateTime = DateTime.MinValue;
+
+			// April 22
+			expected = GetMonthDate (4, 22);
+			text = string.Format ("Sell something due {0} 22nd", Constants.Months [7]);
+
+			Assert.IsTrue (guesser.Parse (text, out task, out dateTime), "#5");
+			Assert.AreEqual ("Sell something", task, "#6");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#7");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#8");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#9");
+			dateTime = DateTime.MinValue;
+
+			// April 13th
+			expected = GetMonthDate (4, 13);
+			text = string.Format ("Sell something due {0} 13th", Constants.Months [7]);
+
+			Assert.IsTrue (guesser.Parse (text, out task, out dateTime), "#10");
+			Assert.AreEqual ("Sell something", task, "#11");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#12");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#13");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#14");
+			dateTime = DateTime.MinValue;
+			
+			// May
+			expected = GetMonthDate (5, 1);
+			text = string.Format ("Sell something due before {0}", Constants.Months [9]);
+
+			Assert.IsTrue (guesser.Parse (text, out task, out dateTime), "#15");
+			Assert.AreEqual ("Sell something", task, "#16");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#17");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#18");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#19");
+			
+			// April 13th
+			expected = GetMonthDate (4, 12);
+			text = string.Format ("Sell something due {0} 12th", Constants.Months [7]);
+
+			Assert.IsTrue (guesser.Parse (text, out task, out dateTime), "#20");
+			Assert.AreEqual ("Sell something", task, "#21");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#22");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#23");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#24");
+			dateTime = DateTime.MinValue;
+		}
+		
+		[Test]
+		public void DueInvalid ()
+		{
+			string task = string.Empty;
+			DateTime dateTime = DateTime.MinValue;
+			
+			// April 22rd - invalid
+			string text = string.Format ("Sell something due {0} 22rd", Constants.Months [7]);
+			Assert.IsFalse (DateGuesser.Instance.Parse (text, 
+			                                            out task,
+			                                            out dateTime), 
+			                "#10");
+
+			// April 32nd
+			text = string.Format ("Sell something due {0} 32nd", Constants.Months [7]);
+			Assert.IsFalse (DateGuesser.Instance.Parse (text, 
+			                                            out task, 
+			                                            out dateTime), 
+			                "#10");
+		}
+
+		#endregion
+
+		#region Helper methods
+
+		DateTime GetMonthDate (int month, int day)
+		{
+			if (DateTime.Now.Month > month)
+				return new DateTime (DateTime.Now.Year + 1, month, day);
+			else
+				return new DateTime (DateTime.Now.Year, month, day);
+		}
+
+		uint GetDayOffset (DayOfWeek futureDay)
+		{
+			uint future = DateGuesser.DayOfWeekToUInt (futureDay);
+			uint today = DateGuesser.DayOfWeekToUInt (DateTime.Today.DayOfWeek);
+			
+			if (future > today)
+				return future - today;
+			else if (today > future)
+				return 7 - (today - future);
+			else
+				return 7;
+		}
+
+		#endregion
+	}
+}
diff --git a/tests/TaskParserFixture.cs b/tests/TaskParserFixture.cs
new file mode 100644
index 0000000..e604edf
--- /dev/null
+++ b/tests/TaskParserFixture.cs
@@ -0,0 +1,475 @@
+// Author:
+//       Mario Carrion <mario@carrion.mx>
+// 
+// Copyright (c) 2010 Mario Carrion
+// 
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+// 
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+using System;
+using NUnit.Framework;
+
+namespace Tasque.Tests {
+
+	[TestFixture]
+	public class TaskParserFixture {
+
+		#region TodayTomorrowFormatter tests
+
+		[Test]
+		public void TomorrowTest ()
+		{
+			string parsedText = null;
+			DateTime dateTime = DateTime.MinValue;
+			TaskParser parser = TaskParser.Instance;
+
+			DateTime expected = DateTime.Now.AddDays (1);
+			Assert.IsTrue (parser.TryParse ("Something tomorrow",
+			                                 out parsedText,
+			                                 out dateTime));
+			Assert.AreEqual ("Something", parsedText, "#0");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#1");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#2");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#3");
+			dateTime = DateTime.MinValue;
+
+			Assert.IsTrue (parser.TryParse ("Buy meat tomorrow for lunch",
+			                                 out parsedText,
+			                                 out dateTime));
+			Assert.AreEqual ("Buy meat for lunch", parsedText, "#4");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#5");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#6");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#7");
+			dateTime = DateTime.MinValue;
+
+			Assert.IsTrue (parser.TryParse ("GET BEER TOMORROW!",
+			                                 out parsedText,
+			                                 out dateTime));
+			Assert.AreEqual ("GET BEER!", parsedText, "#8");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#9");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#10");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#11");
+		}
+
+		[Test]
+		public void TodayTest ()
+		{
+			string parsedText = null;
+			DateTime dateTime = DateTime.MinValue;
+			TaskParser parser = TaskParser.Instance;
+
+			DateTime expected = DateTime.Now;
+			Assert.IsTrue (parser.TryParse ("Something today",
+			                                 out parsedText,
+			                                 out dateTime));
+			Assert.AreEqual ("Something", parsedText, "#0");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#1");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#2");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#3");
+			dateTime = DateTime.MinValue;
+
+			Assert.IsTrue (parser.TryParse ("Buy meat today for lunch",
+			                                 out parsedText,
+			                                 out dateTime));
+			Assert.AreEqual ("Buy meat for lunch", parsedText, "#4");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#5");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#6");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#7");
+			dateTime = DateTime.MinValue;
+
+			Assert.IsTrue (parser.TryParse ("GET BEER TODAY, RIGHT NOW!",
+			                                 out parsedText,
+			                                 out dateTime));
+			Assert.AreEqual ("GET BEER, RIGHT NOW!", parsedText, "#8");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#9");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#10");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#11");
+		}
+
+		#endregion
+
+		#region MonthFormatter tests
+
+		[Test]
+		public void MonthTest ()
+		{
+			string parsedText = null;
+			DateTime dateTime = DateTime.MinValue;
+			TaskParser parser = TaskParser.Instance;
+
+			DateTime expected = DateTime.Now.AddMonths (1);
+			Assert.IsTrue (parser.TryParse ("Something next month",
+			                                 out parsedText,
+			                                 out dateTime),
+			               "#0");
+			Assert.AreEqual ("Something", parsedText, "#1");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#2");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#3");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#4");
+			dateTime = DateTime.MinValue;
+
+			expected = DateTime.Now.AddMonths (3);
+			Assert.IsTrue (parser.TryParse ("Something in 3 months",
+			                                 out parsedText,
+			                                 out dateTime),
+			               "#5");
+			Assert.AreEqual ("Something", parsedText, "#6");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#7");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#8");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#9");
+			dateTime = DateTime.MinValue;
+
+			Assert.IsFalse (parser.TryParse ("Something in -1 months",
+			                                  out parsedText,
+			                                  out dateTime),
+			               "#10");
+			dateTime = DateTime.MinValue;
+
+			// Even though this is invalid English, we accept it
+			expected = DateTime.Now.AddMonths (1);
+			Assert.IsTrue (parser.TryParse ("Something in months",
+			                                 out parsedText,
+			                                 out dateTime),
+			               "#11");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#12");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#13");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#14");
+			dateTime = DateTime.MinValue;
+		}
+
+		#endregion
+
+		#region WeekFormatter tests
+
+		[Test]
+		public void WeekTest ()
+		{
+			string parsedText = null;
+			DateTime dateTime = DateTime.MinValue;
+			TaskParser parser = TaskParser.Instance;
+
+			DateTime expected = DateTime.Now.AddDays (7);
+			Assert.IsTrue (parser.TryParse ("Something next week",
+			                                 out parsedText,
+			                                 out dateTime),
+			               "#0");
+			Assert.AreEqual ("Something", parsedText, "#1");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#2");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#3");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#4");
+			dateTime = DateTime.MinValue;
+
+			expected = DateTime.Now.AddDays (7 * 2);
+			Assert.IsTrue (parser.TryParse ("Something in 2 weeks",
+			                                 out parsedText,
+			                                 out dateTime),
+			               "#5");
+			Assert.AreEqual ("Something", parsedText, "#6");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#7");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#8");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#9");
+			dateTime = DateTime.MinValue;
+
+			Assert.IsFalse (parser.TryParse ("Something in -1 week",
+			                                  out parsedText,
+			                                  out dateTime),
+			               "#10");
+			dateTime = DateTime.MinValue;
+
+			// Even though this is invalid English, we accept it
+			expected = DateTime.Now.AddDays (7);
+			Assert.IsTrue (parser.TryParse ("Something in weeks",
+			                                 out parsedText,
+			                                 out dateTime),
+			               "#11");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#12");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#13");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#14");
+			dateTime = DateTime.MinValue;
+		}
+
+		#endregion
+
+		#region YearFormatter tests
+
+		[Test]
+		public void YearTest ()
+		{
+			string parsedText = null;
+			DateTime dateTime = DateTime.MinValue;
+			TaskParser parser = TaskParser.Instance;
+
+			DateTime expected = DateTime.Now.AddYears (1);
+			Assert.IsTrue (parser.TryParse ("Something next year",
+			                                 out parsedText,
+			                                 out dateTime),
+			               "#0");
+			Assert.AreEqual ("Something", parsedText, "#1");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#2");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#3");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#4");
+			dateTime = DateTime.MinValue;
+
+			expected = DateTime.Now.AddYears (5);
+			Assert.IsTrue (parser.TryParse ("Buy a house in 5 years",
+			                                 out parsedText,
+			                                 out dateTime),
+			               "#5");
+			Assert.AreEqual ("Buy a house", parsedText, "#6");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#7");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#8");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#9");
+			dateTime = DateTime.MinValue;
+
+			Assert.IsFalse (parser.TryParse ("Sleep in -1 years",
+			                                  out parsedText,
+			                                  out dateTime),
+			               "#10");
+			dateTime = DateTime.MinValue;
+
+			// Even though this is invalid English, we accept it
+			expected = DateTime.Now.AddYears (1);
+			Assert.IsTrue (parser.TryParse ("Something in years",
+			                                 out parsedText,
+			                                 out dateTime),
+			               "#11");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#12");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#13");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#14");
+			dateTime = DateTime.MinValue;
+		}
+
+		#endregion
+
+		#region DateFormatter tests
+
+		[Test]
+		public void DateTest ()
+		{
+			string parsedText = null;
+			DateTime dateTime = DateTime.MinValue;
+			TaskParser parser = TaskParser.Instance;
+
+			DateTime expected = GetMonthDate (12, 1);
+			Assert.IsTrue (parser.TryParse ("Something due by December 1st",
+			                                 out parsedText,
+			                                 out dateTime));
+			Assert.AreEqual ("Something", parsedText, "#0");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#1");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#2");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#3");
+			dateTime = DateTime.MinValue;
+
+			expected = GetMonthDate (12, 1);
+			Assert.IsTrue (parser.TryParse ("Something due Dec 1",
+			                                 out parsedText,
+			                                 out dateTime));
+			Assert.AreEqual ("Something", parsedText, "#4");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#5");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#6");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#7");
+			dateTime = DateTime.MinValue;
+
+			expected = GetMonthDate (12, -1);
+			Assert.IsTrue (parser.TryParse ("Something due before December",
+			                                 out parsedText,
+			                                 out dateTime));
+			Assert.AreEqual ("Something", parsedText, "#8");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#9");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#10");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#11");
+			dateTime = DateTime.MinValue;
+
+			expected = GetMonthDate (-1, 15);
+			Assert.IsTrue (parser.TryParse ("Something due by 15th",
+			                                 out parsedText,
+			                                 out dateTime));
+			Assert.AreEqual ("Something", parsedText, "#12");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#13");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#14");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#15");
+			dateTime = DateTime.MinValue;
+
+			// Invalid date, it should be 15th
+			Assert.IsFalse (parser.TryParse ("Something due by 15nd",
+			                                  out parsedText,
+			                                  out dateTime));
+		}
+
+		#endregion
+
+		#region OrdinalFormatter tests
+
+		[Test]
+		public void OrdinalTest ()
+		{
+			string parsedText = null;
+			DateTime dateTime = DateTime.MinValue;
+			TaskParser parser = TaskParser.Instance;
+
+			DateTime expected = GetMonthDate (DateTime.Now.Month, 1);
+			Assert.IsTrue (parser.TryParse ("Something on 1st",
+			                                 out parsedText,
+			                                 out dateTime),
+			               "#0");
+			Assert.AreEqual ("Something", parsedText, "#1");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#2");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#3");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#4");
+			dateTime = DateTime.MinValue;
+
+			expected = GetMonthDate (DateTime.Now.Month, 2);
+			Assert.IsTrue (parser.TryParse ("Something due 2nd",
+			                                 out parsedText,
+			                                 out dateTime));
+			Assert.AreEqual ("Something", parsedText, "#5");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#6");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#7");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#8");
+			dateTime = DateTime.MinValue;
+
+			expected = GetMonthDate (-1, 15);
+			Assert.IsTrue (parser.TryParse ("Something due by 15th",
+			                                 out parsedText,
+			                                 out dateTime));
+			Assert.AreEqual ("Something", parsedText, "#9");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#10");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#11");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#12");
+			dateTime = DateTime.MinValue;
+
+			// Invalid date, it should be 15th
+			Assert.IsFalse (parser.TryParse ("Something on 15nd",
+			                                  out parsedText,
+			                                  out dateTime),
+			                "#13");
+		}
+		
+		#endregion
+
+		#region WeekdayFormatter tests
+
+		[Test]
+		public void WeekdayTest ()
+		{
+			string parsedText = null;
+			DateTime dateTime = DateTime.MinValue;
+			TaskParser parser = TaskParser.Instance;
+			
+			DateTime expected = GetWeekdayDate (DayOfWeek.Monday);
+			Assert.IsTrue (parser.TryParse ("Something on Monday",
+			                                 out parsedText,
+			                                 out dateTime),
+			               "#0");
+			Assert.AreEqual ("Something", parsedText, "#1");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#2");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#3");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#4");
+			dateTime = DateTime.MinValue;
+
+			expected = GetWeekdayDate (DayOfWeek.Friday);
+			Assert.IsTrue (parser.TryParse ("Something due on Friday",
+			                                 out parsedText,
+			                                 out dateTime),
+			               "#5");
+			Assert.AreEqual ("Something", parsedText, "#6");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#7");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#8");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#9");
+			dateTime = DateTime.MinValue;
+
+			expected = GetWeekdayDate (DayOfWeek.Sunday);
+			Assert.IsTrue (parser.TryParse ("Something next sunday",
+			                                 out parsedText,
+			                                 out dateTime),
+			               "#10");
+			Assert.AreEqual ("Something", parsedText, "#11");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#12");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#13");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#14");
+			dateTime = DateTime.MinValue;
+
+			expected = GetWeekdayDate (DayOfWeek.Wednesday);
+			Assert.IsTrue (parser.TryParse ("Something next wed",
+			                                 out parsedText,
+			                                 out dateTime),
+			               "#15");
+			Assert.AreEqual ("Something", parsedText, "#16");
+			Assert.AreEqual (expected.Year, dateTime.Year, "#17");
+			Assert.AreEqual (expected.Month, dateTime.Month, "#18");
+			Assert.AreEqual (expected.Day, dateTime.Day, "#19");
+		}
+
+		#endregion
+
+		#region Helper methods
+
+		DateTime GetMonthDate (int month, int day)
+		{
+			if (month == -1)
+				month = DateTime.Now.Month;
+
+			if (DateTime.Now.Month > month) {
+				if (day == -1)
+					day = DateTime.DaysInMonth (DateTime.Now.Year + 1, month);
+				return new DateTime (DateTime.Now.Year + 1, month, day);
+			}
+			else {
+				if (day == -1)
+					day = DateTime.DaysInMonth (DateTime.Now.Year, month);
+				return new DateTime (DateTime.Now.Year, month, day);
+			}
+		}
+		
+		DateTime GetWeekdayDate (DayOfWeek weekday)
+		{
+			DateTime todayDateTime = DateTime.Now;
+			uint today = ToUint (todayDateTime.DayOfWeek);
+			uint future = ToUint (weekday);
+			if (future > today) 
+				return DateTime.Now.AddDays (future - today);
+			else if (today > future)
+				return DateTime.Now.AddDays (7 - (today - future));
+			else // future is in one week
+				return DateTime.Now.AddDays (7);
+		}
+
+		uint ToUint (DayOfWeek dayOfWeek)
+		{
+			switch (dayOfWeek) {
+			case DayOfWeek.Sunday:
+				return 0;
+			case DayOfWeek.Monday:
+				return 1;
+			case DayOfWeek.Tuesday:
+				return 2;
+			case DayOfWeek.Wednesday:
+				return 3;
+			case DayOfWeek.Thursday:
+				return 4;
+			case DayOfWeek.Friday:
+				return 5;
+			case DayOfWeek.Saturday:
+			default:
+				return 6;
+			}
+		}
+
+		#endregion
+	}
+}
diff --git a/tests/tests.csproj b/tests/tests.csproj
new file mode 100644
index 0000000..1a2f271
--- /dev/null
+++ b/tests/tests.csproj
@@ -0,0 +1,52 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="3.5" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>9.0.21022</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{6DC908EC-E7C2-46CD-A21D-832C0D81D946}</ProjectGuid>
+    <OutputType>Library</OutputType>
+    <RootNamespace>Tasque.Tests</RootNamespace>
+    <AssemblyName>tasque.tests</AssemblyName>
+    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>bin\Debug</OutputPath>
+    <DefineConstants>DEBUG</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>none</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>bin\Release</OutputPath>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="nunit.core, Version=2.4.8.0, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77" />
+    <Reference Include="nunit.framework, Version=2.4.8.0, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="TaskParserFixture.cs" />
+  </ItemGroup>
+  <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
+  <ItemGroup>
+    <ProjectReference Include="..\src\libtasque\libtasque.csproj">
+      <Project>{784C9AA8-2B28-400B-8CC4-DCDC48CA37F0}</Project>
+      <Name>libtasque</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <ProjectExtensions>
+    <MonoDevelop>
+      <Properties>
+        <Deployment.LinuxDeployData generatePcFile="false" />
+      </Properties>
+    </MonoDevelop>
+  </ProjectExtensions>
+</Project>
\ No newline at end of file
